<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Look Ma, No RANSAC | GTSAM</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Look Ma, No RANSAC" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Author: Varun Agrawal Website: varunagrawal.github.io" />
<meta property="og:description" content="Author: Varun Agrawal Website: varunagrawal.github.io" />
<link rel="canonical" href="http://localhost:4000/2019/09/20/robust-noise-model.html" />
<meta property="og:url" content="http://localhost:4000/2019/09/20/robust-noise-model.html" />
<meta property="og:site_name" content="GTSAM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-09-20T00:00:00-04:00" />
<script type="application/ld+json">
{"headline":"Look Ma, No RANSAC","description":"Author: Varun Agrawal Website: varunagrawal.github.io","dateModified":"2019-09-20T00:00:00-04:00","url":"http://localhost:4000/2019/09/20/robust-noise-model.html","datePublished":"2019-09-20T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/09/20/robust-noise-model.html"},"@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/favicon.png"}},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="GTSAM" /></head>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">

  <body class=""><header class="header-holder site-header">

    <div class="wrapper"><a class="site-title" rel="author" href="/">GTSAM</a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>
  
          <div class="trigger"><a class="page-link" href="/get_started/">Get Started</a><a class="page-link" href="/build/">Build</a><a class="page-link" href="/tutorials/">Tutorials</a><a class="page-link" href="/docs/">Docs</a><a class="page-link" href="/blog/">Blog</a><a class="page-link" href="/about/">About</a></div>
        </nav></div>
  </header><div class="main-background "></div>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Look Ma, No RANSAC</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-09-20T00:00:00-04:00" itemprop="datePublished">Sep 20, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <article class="post">

  <div class="jumbotron jumbotron-fluid on-dark-background">
    <div class="container">
        <h1>GTSAM Posts</h1>
    </div>
</div>

  <div class="post-content">
    <p>Author: Varun Agrawal<br />
Website: <a href="https://varunagrawal.github.io">varunagrawal.github.io</a></p>

<p>(<em><strong>Psst</strong>, be sure to clone/download GTSAM 4.0.2 which resolves a bug in the Huber model discussed below, for correct weight behavior</em>)</p>

<h2 id="introduction">Introduction</h2>

<figure class="center">
  <img src="/assets/images/robust_estimators/se2_matches.png" alt="Matches between books" />
  <figcaption><b>Figure 1</b> Two books on a plane separated by an SE(2) transform, and some manually selected feature matches between them. There are some clearly incorrect matches, which are <b>outliers</b>.</figcaption>
</figure>

<p>Robust error models are powerful tools for supplementing parameter estimation algorithms with the added capabilities of modeling outliers. Parameter estimation is a fundamental tool used in many fields, especially in perception and robotics, and thus performing robust parameter estimation across a wide range of applications and scenarios is crucial to strong performance for many applications. This necessitates the need to manage outliers in our measurements, and robust error models provide us the means to do so. Robust error models are amenable to easy plug-and-play use in pre-existing optimization frameworks, requiring minimal changes to existing pipelines.</p>

<p>Using robust error models can even obviate the need for more complex, non-deterministic algorithms such as Random Sample Consensus (a.k.a. RANSAC), a fundamental tool for parameter estimation in many a roboticist’s toolbox for years. While RANSAC has proven to work well in practice, it might need a high number of runs to converge to a good solution. Robust error models are conceptually easy and intuitive and can be used by themselves or in conjunction with RANSAC.</p>

<p>In this blog post, we demonstrate the capabilities of robust error models which downweigh outliers to provide better estimates of the parameters of interest. To illustrate the benefits of robust error models, take a look at <strong>Figure 1</strong>. We show two books next to each other, transformed by an $SE(2)$ transform, with some manually labeled point matches between the two books. We have added some outliers to more realistically model the problem.
As we will see later in the post, the estimates from RANSAC and a robust estimation procedure are quite similar, even though the ratio of inliers to outliers is $2:1$.</p>

<h2 id="parameter-estimation---a-short-tutorial">Parameter Estimation - A Short Tutorial</h2>

<p>We begin by reviewing techniques for parameter estimation as outlined by the <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/RR-2676.pdf">tutorial by Zhengyou Zhang</a>, as applied to our $SE(2)$. Given some matches ${(s,s’)}$ between the two images, we want to estimate the the $SE(2)$ parameters $\theta$ that transform a feature $s$ in the first image to a feature $s’$ in the  second image:</p>

<p>\[ s’ = f(\theta ; s) \]</p>

<p>Of course, this generalizes to other transformations, including 3D-2D problems. This is a ubiquitous problem seen in multiple domains of perception and robotics and is referred to as <strong>parameter estimation</strong>.</p>

<p>A standard framework to estimate the parameters is via the Least-Squares formulation. We usually have many more observations than we have parameters, i.e., the problem is now overdetermined. To handle this, we minimize the sum of square <strong>residuals</strong> $f(\theta ; s_i) - s’_i$, for $i\in1\ldots N$:</p>

<p>\[ E_{LS}(\theta) =  \sum_i \vert\vert f(\theta ; s_i) - s’_i \vert\vert^2 \]</p>

<p>which we refer to as <strong>the cost function</strong> or <strong>the objective function</strong>.
In the case of $SE(2)$ the parameters $\theta$ should be some parameterization of a transformation matrix, having three degrees of freedom (DOF). A simple way to accomplish this is to have $\theta=(x,y,\alpha)$.</p>

<p>Our measurement functions are generally non-linear, and hence we need to linearize the measurement function around an estimate of $\theta$. GTSAM will iteratively do so via optimization procedures such as Gauss-Newton, Levenberg-Marquardt, or Dogleg. Linearization is done via the <strong>Taylor expansion</strong> around a linearization point $\theta_0$:</p>

<p>\[ f(\theta + \Delta\theta; s) = f(\theta; s) + J(\theta; s)\Delta\theta \]</p>

<p>This gives us the following linearized least squares objective function:</p>

<p>\[ E_{LS, \theta_0} = \sum_i \vert\vert f(\theta; s_i) + J(\theta; s_i)\Delta\theta - s_i’ \vert\vert^2 \]</p>

<p>Since the above is now linear in $\Delta\theta$, GTSAM can solve it using either sparse Cholesky or QR factorization.</p>

<h2 id="robust-error-models">Robust Error Models</h2>

<p>We have derived the basic parameter optimization approach in the previous section and seen how the choice of the optimization function affects the optimality of our solution. However, another aspect we need to take into account is the effect of outliers on our optimization and final parameter values.</p>

<p>By default, the optimization objectives outlined above try to model all measurements equally. This means that in the presence of outliers, the optimization process might give us parameter estimates that try to fit these outliers, sacrificing accuracy on the inliers. More formally, given the <em>residual</em> $r_i$ of the $i^{th}$ match, i.e. the difference between the $i^{th}$ observation and the fitted value, the standard least squares approach attempts to optimize the sum of all the squared residuals. This can lead to the estimated parameters being distorted due to the equal weighting of all data points. Surely, there must be a way for the objective to model inliers and outliers in a clever way based on the residual errors?</p>

<p>One way to tackle the presence of outliers is a family of models known as <strong>Robust Error Models</strong> or <strong>M-estimators</strong>. The M-estimators try to reduce the effect of outliers by replacing the squared residuals with a function of the residuals $\rho$ that weighs each residual term by some value:</p>

<p>\[ p = min \sum_i^n \rho(r_i) \]</p>

<p>To allow for optimization, we define $\rho$ to be a symmetric, positive-definite function, thus it has a unique minimum at zero, and is less increasing than square.</p>

<p>The benefit of this formulation is that we can now solve the above minimization objective as an <strong>Iteratively Reweighted Least Squares</strong> problem. The M-estimator of the parameter vector $p$ based on $\rho$ is the value of the parameters which solves</p>

<p>\[ \sum_i \psi(r_i)\frac{\delta r_i}{\delta p_j} = 0 \]</p>

<p>for $j = 1, …, m$ (recall that the maximum/minimum of a function is at the point its derivative is equal to zero). Above, $\psi(x) = \frac{\delta \rho(x)}{\delta x}$ is called the <strong>influence function</strong>, which we can use to define a <strong>weight function</strong> $w(x) = \frac{\psi{x}}{x}$ giving the original derivative as</p>

<p>\[ \sum_i w(r_i) r_i \frac{\delta r_i}{\delta p_j} = 0 \]</p>

<p>which is exactly the system of equations we obtain from iterated reweighted least squares.</p>

<p>In layman’s terms, the influence function $\psi(x)$ measures the influence of a data point on the value of the parameter estimate. This way, the estimated parameters are intelligent to outliers and only sensitive to inliers, since the are no longer susceptible to being significantly modified by a single match, thus making them <strong>robust</strong>.</p>

<h3 id="m-estimator-constraints">M-estimator Constraints</h3>

<p>While M-estimators provide us with significant benefits with respect to outlier modeling, they do come with some constraints which are required to enable their use in a wide variety of optimization problems.</p>

<ul>
  <li>The influence function should be bounded.</li>
  <li>The robust estimator should be unique, i.e. it should have a unique minimum. This implies that <em>the individual $\rho$-function is convex in variable <strong>p</strong></em>.</li>
  <li>The objective should have a gradient, even when the 2nd derivative is singular.</li>
</ul>

<h3 id="common-m-estimators">Common M-estimators</h3>

<p>Below we list some of the common estimators from the literature and which are available out of the box in GTSAM. We also provide accompanying graphs of the corresponding <strong>$\rho$ function</strong>, the <strong>influence function</strong>, and the <strong>weight function</strong> in order, allowing one to visualize the differences and effects of each estimators influence function.</p>

<ol>
  <li>
    <p>Fair
<img src="/assets/images/robust_estimators/fair.png" alt="fair m-estimator" /></p>
  </li>
  <li>
    <p>Huber
<img src="/assets/images/robust_estimators/huber.png" alt="huber m-estimator" /></p>
  </li>
  <li>
    <p>Cauchy
<img src="/assets/images/robust_estimators/cauchy.png" alt="cauchy m-estimator" /></p>
  </li>
  <li>
    <p>Geman-McClure
<img src="/assets/images/robust_estimators/gemanmcclure.png" alt="geman-mcclure m-estimator" /></p>
  </li>
  <li>
    <p>Welsch
<img src="/assets/images/robust_estimators/welsch.png" alt="welsch m-estimator" /></p>
  </li>
  <li>
    <p>Tukey
<img src="/assets/images/robust_estimators/tukey.png" alt="tukey m-estimator" /></p>
  </li>
</ol>

<h2 id="example-with-huber-noise-model">Example with Huber Noise Model</h2>

<p>Now it’s time for the real deal. So far we’ve spoken about how great robust estimators are, and how they can be easily modeled in a least squares objective, but having a concrete example and application can really help illuminate these concepts and demonstrate the power of a robust error model. In this specific case we use the <strong>Huber M-estimator</strong>, though any other provided M-estimator can be used depending on the application or preference.</p>

<p>For our example application, the estimation of an $SE(2)$ transformation between two objects (a scenario commonly seen in PoseSLAM applications), we go back to our image of the two books from the introduction, which we have manually labeled with matches and outliers. A RANSAC estimate using the matches gives us the $SE(2)$ paramters <code class="highlighter-rouge">(347.15593, 420.31040, 0.39645)</code>.</p>

<figure class="center">
  <img src="/assets/images/robust_estimators/se2_matches.png" alt="Matches between books" />
  <figcaption><b>Figure 2</b>: Matches between the 2 books.</figcaption>
</figure>

<p>To begin, we apply a straightforward optimization process based on Factor Graphs. Using GTSAM, this can be achieved in a few lines of code. We show the core part of the example below, omitting the housekeeping and data loading for brevity.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This is the value we wish to estimate
</span><span class="n">Pose2_</span> <span class="n">pose_expr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// Set up initial values, and Factor Graph
</span><span class="n">Values</span> <span class="n">initial</span><span class="p">;</span>
<span class="n">ExpressionFactorGraph</span> <span class="n">graph</span><span class="p">;</span>

<span class="c1">// provide an initial estimate which is pretty much random
</span><span class="n">initial</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Pose2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">));</span>

<span class="c1">// We assume the same noise model for all points (since it is the same camera)
</span><span class="k">auto</span> <span class="n">measurementNoise</span> <span class="o">=</span> <span class="n">noiseModel</span><span class="o">::</span><span class="n">Isotropic</span><span class="o">::</span><span class="n">Sigma</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

<span class="c1">// Now we add in the factors for the measurement matches.
// Matches is a vector of 4 tuples (index1, keypoint1, index2, keypoint2)
</span><span class="kt">int</span> <span class="n">index_i</span><span class="p">,</span> <span class="n">index_j</span><span class="p">;</span>
<span class="n">Point2</span> <span class="n">p</span><span class="p">,</span> <span class="n">measurement</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Point2</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">Point2</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">matches</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="n">it</span> <span class="o">!=</span> <span class="n">matches</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">index_i</span><span class="p">,</span> <span class="n">measurement</span><span class="p">,</span> <span class="n">index_j</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>

    <span class="n">Point2_</span> <span class="n">predicted</span> <span class="o">=</span> <span class="n">transformTo</span><span class="p">(</span><span class="n">pose_expr</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    
    <span class="c1">// Add the Point2 expression variable, an initial estimate, and the measurement noise.
</span>    <span class="n">graph</span><span class="p">.</span><span class="n">addExpressionFactor</span><span class="p">(</span><span class="n">predicted</span><span class="p">,</span> <span class="n">measurement</span><span class="p">,</span> <span class="n">measurementNoise</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Optimize and print basic result
</span><span class="n">Values</span> <span class="n">result</span> <span class="o">=</span> <span class="n">LevenbergMarquardtOptimizer</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">initial</span><span class="p">).</span><span class="n">optimize</span><span class="p">();</span>
<span class="n">result</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Final Result:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</code></pre></div></div>

<p>It is important to note that our initial estimate for the transform values is pretty arbitrary.
Running the above code give us the transform values <code class="highlighter-rouge">(305.751, 520.127, 0.284743)</code>, which when compared to the RANSAC estimate doesn’t look so good.</p>

<p>Now how about we try using M-estimators via the built-in robust error models? This is a two line change as illustrated below:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This is the value we wish to estimate
</span><span class="n">Pose2_</span> <span class="n">pose_expr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// Set up initial values, and Factor Graph
</span><span class="n">Values</span> <span class="n">initial</span><span class="p">;</span>
<span class="n">ExpressionFactorGraph</span> <span class="n">graph</span><span class="p">;</span>

<span class="c1">// provide an initial estimate which is pretty much random
</span><span class="n">initial</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Pose2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">));</span>

<span class="c1">// We assume the same noise model for all points (since it is the same camera)
</span><span class="k">auto</span> <span class="n">measurementNoise</span> <span class="o">=</span> <span class="n">noiseModel</span><span class="o">::</span><span class="n">Isotropic</span><span class="o">::</span><span class="n">Sigma</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

<span class="cm">/********* First change *********/</span>
<span class="c1">// We define our robust error model here, providing the default parameter value for the estimator.
</span><span class="k">auto</span> <span class="n">huber</span> <span class="o">=</span> <span class="n">noiseModel</span><span class="o">::</span><span class="n">Robust</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">noiseModel</span><span class="o">::</span><span class="n">mEstimator</span><span class="o">::</span><span class="n">Huber</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="mf">1.345</span><span class="p">),</span> <span class="n">measurementNoise</span><span class="p">);</span>

<span class="c1">// Now we add in the factors for the measurement matches.
// Matches is a vector of 4 tuples (index1, keypoint1, index2, keypoint2)
</span><span class="kt">int</span> <span class="n">index_i</span><span class="p">,</span> <span class="n">index_j</span><span class="p">;</span>
<span class="n">Point2</span> <span class="n">p</span><span class="p">,</span> <span class="n">measurement</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Point2</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">Point2</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">matches</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="n">it</span> <span class="o">!=</span> <span class="n">matches</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">index_i</span><span class="p">,</span> <span class="n">measurement</span><span class="p">,</span> <span class="n">index_j</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>

    <span class="n">Point2_</span> <span class="n">predicted</span> <span class="o">=</span> <span class="n">transformTo</span><span class="p">(</span><span class="n">pose_expr</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

    <span class="c1">// Add the Point2 expression variable, an initial estimate, and the measurement noise.
</span>    <span class="c1">// The graph takes in factors with the robust error model.
</span>    <span class="cm">/********* Second change *********/</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">addExpressionFactor</span><span class="p">(</span><span class="n">predicted</span><span class="p">,</span> <span class="n">measurement</span><span class="p">,</span> <span class="n">huber</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Optimize and print basic result
</span><span class="n">Values</span> <span class="n">result</span> <span class="o">=</span> <span class="n">LevenbergMarquardtOptimizer</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">initial</span><span class="p">).</span><span class="n">optimize</span><span class="p">();</span>
<span class="n">result</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Final Result:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</code></pre></div></div>

<p>This version of the parameter estimation gives us the $SE(2)$ transform <code class="highlighter-rouge">(363.76, 458.966, 0.392419)</code>. Quite close for only 15 total matches, especially considering 5 of the 10 were outliers! The estimates are expected to improve with more matches to further constrain the problem.</p>

<p>As an alternate example, we look at an induced $SE(2)$ transform and try to estimate it from scratch (no manual match labeling. Our source image is one of crayon boxes retrieved from the internet, since this image lends itself to good feature detection.</p>

<p><img src="/assets/images/robust_estimators/original_image.png" alt="original image" /></p>

<p>To model an $SE(2)$ transformation, we apply a perspective transform to the image. The transformation applied is <code class="highlighter-rouge">(x, y, theta) = (4.711, 3.702, 0.13963)</code>. This gives us a ground truth value to compare our methods against. The transformed image can be seen below.</p>

<p><img src="/assets/images/robust_estimators/transformed_image.png" alt="Warped image" /></p>

<p>We run the standard pipeline of SIFT feature extraction and FLANN+KDTree based matching to obtain a set of matches. At this point we are ready to evaluate the different methods of estimating the transformation.</p>

<p>The vanilla version of the parameter estimation gives us <code class="highlighter-rouge">(6.26294, -14.6573, 0.153888)</code> which is pretty bad. However, the version with robust error models gives us <code class="highlighter-rouge">(4.75419, 3.60199, 0.139674)</code>, which is a far better estimate when compared to the ground truth, despite the initial estimate for the transform being arbitrary. This makes it apparent that the use of robust estimators and subsequently robust error models is the way to go for use cases where outliers are a concern. Of course, providing better initial estimates will only improve the final estimate.</p>

<p>You may ask how does this compare to our dear old friend RANSAC? Using the OpenCV implementation of RANSAC, a similar pipeline gives use the following $SE(2)$ values: <code class="highlighter-rouge">(4.77360, 3.69461, 0.13960)</code>.</p>

<p>We show, in order, the original image, its warped form, and the recovered image from the $SE(2)$ transformation estimation. The first image is from the ground truth transform, the second one is using RANSAC, the next one is using a vanilla parameter estimation approach, and the last one uses robust error models. As you can see, while the vanilla least-squares optimization result is poor compared to the ground truth, the RANSAC and the robust error model recover the transformation correctly, with the robust error model’s result being comparable to the RANSAC one.</p>

<figure class="center">
  <img src="/assets/images/robust_estimators/ground_truth_images.png" alt="ground truth" />
  <figcaption>Image warping and recovery using ground truth SE(2) transform. The first image is the original image, the 2nd image is the transformed image, and the last one is the image we get on applying the reverse $SE(2)$ transform.</figcaption>
</figure>

<figure class="center">
  <img src="/assets/images/robust_estimators/ransac_images.png" alt="ransac" />
  <figcaption>Image warping and recovery using RANSAC.</figcaption>
</figure>

<figure class="center">
  <img src="/assets/images/robust_estimators/vanilla_model_images.png" alt="vanilla" />
  <figcaption>Image warping and recovery using plain old parameter estimation. You can see that the 3rd (recovered) image does not line up correctly.</figcaption>
</figure>

<figure class="center">
  <img src="/assets/images/robust_estimators/robust_model_images.png" alt="robust error model" />
  <figcaption>Image warping and recovery using robust error models with parameter estimation. These results are comparable to the ones from RANSAC, demonstrating the promise of robust error models.</figcaption>
</figure>

<!-- That's pretty close too, so why go through the headache of using robust error models? For one, unlike RANSAC, robust error models are deterministic and possess defined behavior. Moreover, one does not need to run multiple runs of optimization to obtain a consistent result, compared to RANSAC which may require hundreds of runs to converge to a good result. -->

<!-- ## Robust Error Models + RANSAC -->

<h2 id="conclusion">Conclusion</h2>

<p>In this post, we have seen the basics of parameter estimation, a ubiquitous mathematical framework for many perception and robotics problems, and we have seen how this framework is susceptible to perturbations from outliers which can throw off the final estimate. More importantly, we have seen how a simple tool called the Robust M-estimator can easily help us deal with these outliers and their effects. An example case for $SE(2)$ transform estimation demonstrates not only their ease of use with GTSAM, but also the efficacy of the solution generated, especially when compared to widely used alternatives such as RANSAC.</p>

<p>Furthermore, robust estimators are deterministic, ameliorating the need for the complexity that comes inherent with RANSAC. While RANSAC is a great tool, robust error models provide us with a solid alternative to be considered. With the benefits of speed, accuracy, and ease of use, robust error models make a strong case for their adoption for many related problems and we hope you will give them a shot the next time you use GTSAM.</p>


  </div>

</article>

  </div><a class="u-url" href="/2019/09/20/robust-noise-model.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">GTSAM</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">GTSAM</li><li><a class="u-email" href="mailto:frank.dellaert@gtsam.org">frank.dellaert@gtsam.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/borglab"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">borglab</span></a></li><li><a href="https://www.twitter.com/gtsam4"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">gtsam4</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>GTSAM is a BSD-licensed C++ library that implements sensor fusion for robotics and computer vision using factor graphs.</p>
      </div>
    </div>

  </div>

</footer>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
          renderMathInElement(document.body, {
              delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\[", right: "\\]", display: true},
                {left: "\\(", right: "\\)", display: false},
              ]
          });
      });
    </script>

  </body>

</html>