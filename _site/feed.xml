<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-11-07T21:01:44-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">GTSAM</title><subtitle>GTSAM is a BSD-licensed C++ library that implements sensor fusion for robotics and computer vision using factor graphs.</subtitle><entry><title type="html">LQR Control Using Factor Graphs</title><link href="http://localhost:4000/2019/11/07/lqr-control.html" rel="alternate" type="text/html" title="LQR Control Using Factor Graphs" /><published>2019-11-07T00:00:00-05:00</published><updated>2019-11-07T00:00:00-05:00</updated><id>http://localhost:4000/2019/11/07/lqr-control</id><content type="html" xml:base="http://localhost:4000/2019/11/07/lqr-control.html">&lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/css/slideshow.css&quot; /&gt;

&lt;p&gt;Authors: &lt;a href=&quot;https://gerry-chen.com&quot;&gt;Gerry Chen&lt;/a&gt; and &lt;a href=&quot;https://www.linkedin.com/in/yetong-zhang-9b810a105/&quot;&gt;Yetong Zhang&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;a name=&quot;LQR_example&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;center&quot; style=&quot;width:90%;margin-bottom:&quot;&gt;
  &lt;a href=&quot;/assets/images/lqr_control/LQR_FGvsRicatti.png&quot;&gt;&lt;img src=&quot;/assets/images/lqr_control/LQR_FGvsRicatti.png&quot; alt=&quot;Comparison between LQR control as solved by factor graphs and by the Ricatti Equation. (they are the same)&quot; style=&quot;margin-bottom:10px;&quot; /&gt;&lt;/a&gt;
  &lt;figcaption&gt;&lt;b&gt;Figure 1&lt;/b&gt; Example LQR control solutions as solved by factor graphs (middle) and the traditional Discrete Algebraic Ricatti Equations (right).  The optimal control gains and cost-to-go factors are compared (left).  All plots show exact agreement between factor graph and Ricatti equation solutions.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;In this post we explain how optimal control problems can be formulated as factor graphs and solved
by performing variable elimination on the factor graph.&lt;/p&gt;

&lt;p&gt;Specifically, we will show the factor graph formulation and solution for the
&lt;strong&gt;Linear Quadratic Regulator (LQR)&lt;/strong&gt; as this problem conveys the essential ideas of using factor
graphs for optimal control, though they can be readily extended to LQG, iLQR, DDP, and reinforcement
learning (stay tuned for future posts).  We consider the &lt;strong&gt;finite-horizon, discrete LQR problem&lt;/strong&gt;
(though the control law converges to the infinite-horizon case quite quickly as illustrated in
&lt;a href=&quot;#LQR_example&quot;&gt;Figure 1a&lt;/a&gt;).  The task is to find the optimal controls $u_k$ at time instances $t_k$
so that a total cost is minimized, given &lt;a href=&quot;#eq:dyn_model&quot;&gt;(1)&lt;/a&gt; a dynamics model,
&lt;a href=&quot;#eq:state_cost&quot;&gt;(2)&lt;/a&gt; a cost function on states, and &lt;a href=&quot;#eq:action_cost&quot;&gt;(3)&lt;/a&gt; a cost
function on actions. In the linear-quadratic problem , these are of the
form (&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear%E2%80%93quadratic_regulator#Finite-horizon,_discrete-time_LQR&quot;&gt;Wikipedia&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;eq:dyn_model&quot;&gt;&lt;/a&gt; \[ x_{k+1} = Ax_k + Bu_k \tag{1} \]
&lt;a name=&quot;eq:state_cost&quot;&gt;&lt;/a&gt; \[ L(x_k) = x_k^T Q x_k \tag{2} \]
&lt;a name=&quot;eq:action_cost&quot;&gt;&lt;/a&gt; \[ L(u_k) = u_k^T R u_k \tag{3} \]&lt;/p&gt;

&lt;p&gt;The optimal controls over time can be expressed as the constrained optimization problem:&lt;/p&gt;

&lt;p&gt;\[ \argmin\limits_{u_{1\sim k}}\sum\limits_{i=1}^n x_i^T Q x_i + u_i^T R u_i \]
\[ s.t. ~~ x_{t+1}=Ax_t+Bu_t ~~\text{for } t=1 \text{ to } T-1 \]&lt;/p&gt;

&lt;p&gt;We can visualize the objective function and constraints in the form of a factor
graph as shown in &lt;a href=&quot;#fg_scratch&quot;&gt;Figure 2&lt;/a&gt;. This is a simple Markov chain, with the oldest
states and actions on the left, and the newest states and actions on the right. &lt;strong&gt;The
ternary factors represent the dynamics model constraints and the unary
factors represent the state and control costs we seek to minimize via least-squares.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;fg_scratch&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/lqr_control/VE/fg_lqr.png&quot; alt=&quot;Factor graph structure. The objective factors are marked with dashed lines, and the constrain factors are marked with solid lines.&quot; /&gt;
    &lt;figcaption&gt;&lt;b&gt;Figure 2&lt;/b&gt; Factor graph structure for an LQR problem with 3 time steps. The cost factors are marked with dashed lines and the dynamics constraint factors are marked with solid lines.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;variable-elimination&quot;&gt;Variable Elimination&lt;/h2&gt;
&lt;p&gt;To optimize the factor graph, which represents minimizing the least squares objectives above, we can simply eliminate the factors from right
to left.  In this section we demonstrate the variable elimination algebraically, but discussion on the implementation in GTSAM is also
provided in the &lt;a href=&quot;#least-squares-implementation-in-gtsam&quot;&gt;Appendix&lt;/a&gt;.&lt;/p&gt;

&lt;!-- ********************** BEGIN VARIABLE ELIMINATION SLIDESHOW ********************** --&gt;
&lt;!-- Slideshow container, based on https://www.w3schools.com/howto/howto_js_slideshow.asp --&gt;
&lt;div class=&quot;slideshow-container&quot;&gt;
  &lt;div class=&quot;mySlides 0&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;!-- &lt;div class=&quot;numbertext&quot;&gt;2 / 3&lt;/div&gt; --&gt;
    &lt;a name=&quot;fig_eliminate_x&quot;&gt;&lt;/a&gt;
    &lt;figure class=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg1.png&quot; alt=&quot;Elimination of state $x_2$&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 3a&lt;/b&gt; Elimination of state $x_2$&lt;/figcaption&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;div class=&quot;mySlides 0&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;!-- &lt;div class=&quot;numbertext&quot;&gt;2 / 3&lt;/div&gt; --&gt;
    &lt;a name=&quot;fig_eliminate_x&quot;&gt;&lt;/a&gt;
    &lt;figure class=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg2.png&quot; alt=&quot;Elimination of state $x_2$&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 3b&lt;/b&gt; Elimination of state $x_2$&lt;/figcaption&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;div class=&quot;mySlides 0&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;!-- &lt;div class=&quot;numbertext&quot;&gt;3 / 3&lt;/div&gt; --&gt;
    &lt;a name=&quot;fig_eliminate_u&quot;&gt;&lt;/a&gt;
    &lt;figure class=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg3.png&quot; alt=&quot;Elimination of state $u_1$&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 4a&lt;/b&gt; Elimination of state $u_1$&lt;/figcaption&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;div class=&quot;mySlides 0&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;!-- &lt;div class=&quot;numbertext&quot;&gt;3 / 3&lt;/div&gt; --&gt;
    &lt;a name=&quot;fig_eliminate_u&quot;&gt;&lt;/a&gt;
    &lt;figure class=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg4.png&quot; alt=&quot;Elimination of state $u_1$&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 4b&lt;/b&gt; Elimination of state $u_1$&lt;/figcaption&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;div class=&quot;mySlides 0&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;!-- &lt;div class=&quot;numbertext&quot;&gt;3 / 3&lt;/div&gt; --&gt;
    &lt;a name=&quot;fig_bayes_net&quot;&gt;&lt;/a&gt;
    &lt;figure class=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg5.png&quot; alt=&quot;Bayes net&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 5a&lt;/b&gt; Repeat elimination until the graph is reduced to a Bayes net&lt;/figcaption&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;div class=&quot;mySlides 0&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;!-- &lt;div class=&quot;numbertext&quot;&gt;3 / 3&lt;/div&gt; --&gt;
    &lt;a name=&quot;fig_bayes_net&quot;&gt;&lt;/a&gt;
    &lt;figure class=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg6.png&quot; alt=&quot;Bayes net&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 5b&lt;/b&gt; Repeat elimination until the graph is reduced to a Bayes net&lt;/figcaption&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;div class=&quot;mySlides 0&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;!-- &lt;div class=&quot;numbertext&quot;&gt;3 / 3&lt;/div&gt; --&gt;
    &lt;a name=&quot;fig_bayes_net&quot;&gt;&lt;/a&gt;
    &lt;figure class=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg7.png&quot; alt=&quot;Bayes net&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 5c&lt;/b&gt; Repeat elimination until the graph is reduced to a Bayes net&lt;/figcaption&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;div class=&quot;mySlides 0&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;!-- &lt;div class=&quot;numbertext&quot;&gt;3 / 3&lt;/div&gt; --&gt;
    &lt;a name=&quot;fig_bayes_net&quot;&gt;&lt;/a&gt;
    &lt;figure class=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg8.png&quot; alt=&quot;Bayes net&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 5d&lt;/b&gt; Repeat elimination until the graph is reduced to a Bayes net&lt;/figcaption&gt;
    &lt;/figure&gt;
  &lt;/div&gt;
  &lt;!-- Next and previous buttons --&gt;
  &lt;a class=&quot;prev&quot; onclick=&quot;plusSlides(-1,0)&quot;&gt;&amp;#10094;&lt;/a&gt;
  &lt;a class=&quot;next&quot; onclick=&quot;plusSlides(1,0)&quot;&gt;&amp;#10095;&lt;/a&gt;

&lt;/div&gt;
&lt;p&gt;&lt;!-- slideshow-container --&gt;&lt;/p&gt;

&lt;!-- The dots/circles --&gt;
&lt;div style=&quot;text-align:center&quot;&gt;
  &lt;span class=&quot;dot 0&quot; onclick=&quot;currentSlide(1,0)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 0&quot; onclick=&quot;currentSlide(2,0)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 0&quot; onclick=&quot;currentSlide(3,0)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 0&quot; onclick=&quot;currentSlide(4,0)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 0&quot; onclick=&quot;currentSlide(5,0)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 0&quot; onclick=&quot;currentSlide(6,0)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 0&quot; onclick=&quot;currentSlide(7,0)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 0&quot; onclick=&quot;currentSlide(8,0)&quot;&gt;&lt;/span&gt;
&lt;/div&gt;

&lt;!-- this css is to make the scroll bar disappear when the mouse isn't over the scrollable div...
Taken from my website: https://github.com/gchenfc/gerrysworld2/blob/master/css/activity.css --&gt;
&lt;style&gt;
.scrollablecontent::-webkit-scrollbar {
    width: 5px;
    height: 12px;
}
.scrollablecontent::-webkit-scrollbar-track {
    background: transparent;
}
.scrollablecontent::-webkit-scrollbar-thumb {
    background: #ddd;
    visibility:hidden;
}
.scrollablecontent:hover::-webkit-scrollbar-thumb {
    visibility:visible;
}
&lt;/style&gt;

&lt;!-- ********************** END VARIABLE ELIMINATION SLIDESHOW ********************** --&gt;

&lt;!-- ************************ BEGIN SCROLLABLE ELIMINATION DESCRIPTION ************************ --&gt;
&lt;div class=&quot;scrollablecontent&quot; id=&quot;sec:elim_scrollable&quot; style=&quot;overflow-y: scroll; height:400px; overflow-x: hidden; background-color:rgba(0,0,0,0.05); padding:0 8px; margin-bottom: 10px;&quot;&gt;
  &lt;!-- ************** STATE ************** --&gt;
  &lt;p&gt;&lt;a id=&quot;sec:elim_state&quot;&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;h3 id=&quot;eliminate-a-state&quot;&gt;Eliminate a State&lt;/h3&gt;
  &lt;p&gt;Let us start at the last state, $x_2$. Gathering the three factors (marked in
red &lt;a href=&quot;#fig_eliminate_x&quot;&gt;Figure 3a&lt;/a&gt;), we have the following objective function, $\phi_1$, and constraint equation, &lt;a href=&quot;#eq:constrain&quot;&gt;(4)&lt;/a&gt;, on $x_2$, $u_1$ and $x_1$:&lt;/p&gt;

  &lt;p&gt;&lt;a name=&quot;eq:potential&quot;&gt;&lt;/a&gt;
\[ \phi_1(x_1, u_1, x_2) = x_1^T Q x_1 + u_1^T R u_1 + x_2^T Q x_2
\tag{4} \]
&lt;a name=&quot;eq:constrain&quot;&gt;&lt;/a&gt;
\[ x_2 = Ax_1 + Bu_1 \tag{5} \]&lt;/p&gt;

  &lt;p&gt;By substituting $x_2$ into &lt;a href=&quot;#eq:potential&quot;&gt;(4)&lt;/a&gt; using the &lt;a href=&quot;#eq:constrain&quot;&gt;(5)&lt;/a&gt;, we can rewrite
$\phi_1$ as a function of $x_1$ and $u_1$:&lt;/p&gt;

  &lt;p&gt;&lt;a name=&quot;eq:potential_simplified&quot;&gt;&lt;/a&gt;
\[ \phi_1(x_1, u_1) = x_1^T Q x_1 + u_1^T R u_1 + (Ax_1 + Bu_1)^T Q (Ax_1 + Bu_1)
\tag{6} \]&lt;/p&gt;

  &lt;p&gt;The resulting factor graph is illustrated in &lt;a href=&quot;#fig_eliminate_x&quot;&gt;Figures 3a&lt;/a&gt; and
&lt;a href=&quot;#fig_eliminate_x&quot;&gt;3b&lt;/a&gt;. To summarize, we used the dynamics constraint to eliminate variable
$x_2$ as well as the two factors marked in red, and replace them with a new binary factor on $x_1$
and $u_1$, marked in blue.
&lt;!-- ************** CONTROL ************** --&gt;
&lt;a id=&quot;sec:elim_ctrl&quot;&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;h3 id=&quot;eliminate-a-control&quot;&gt;Eliminate a Control&lt;/h3&gt;
  &lt;p&gt;Note that &lt;a href=&quot;#eq:potential_simplified&quot;&gt;(6)&lt;/a&gt; defines an (unnormalized) joint
Gaussian density on variables $x_1$ and $u_1$. We solve for the mean of $u_1$ by
setting the derivative of &lt;a href=&quot;#eq:potential_simplified&quot;&gt;(6)&lt;/a&gt; wrt $u_1$ to zero,
yielding the expression of $u_1$ given $x_1$ as (detailed calculation in the
&lt;a href=&quot;#eliminate-u_1&quot;&gt;Appendix&lt;/a&gt;)&lt;/p&gt;

  &lt;p&gt;&lt;a name=&quot;eq:control_law&quot;&gt;&lt;/a&gt;
\[ \begin{aligned} 
u_1 &amp;amp;= -(R+B^TQB)^{-1}B^TQAx_1 \tag{7} \\ 
&amp;amp;= K_1x_1 
\end{aligned} \]&lt;/p&gt;

  &lt;p&gt;where $K_1\coloneqq -(R+B^TQB)^{-1}B^TQA$. We can further substitute the expression of $u_1$
into our potential &lt;a href=&quot;#eq:potential_simplified&quot;&gt;(6)&lt;/a&gt; so that we have (detailed
calculation in the &lt;a href=&quot;#marginalization-cost-on-x_1&quot;&gt;Appendix&lt;/a&gt;)&lt;/p&gt;

  &lt;p&gt;&lt;a name=&quot;eq:cost_update&quot;&gt;&lt;/a&gt;
\[ \begin{aligned} 
\phi_1(x_1) &amp;amp;= x_1^T Q x_1 + (K_1x_1)^T RK_1x_1 + (Ax_1 + BKx_1)^T Q (Ax_1 + 
BKx_1) \\ 
&amp;amp;= x_1^T(Q+A^TQA - K_1^TB^TQA)x_1 \\ 
&amp;amp;= x_1^T V_1 x_2 \tag{8} 
\end{aligned} \]
where $V_1\coloneqq Q+A^TQA - K_1^TB^TQA$.&lt;/p&gt;

  &lt;p&gt;As illustrated in &lt;a href=&quot;#fig_eliminate_u&quot;&gt;Figure 4&lt;/a&gt;, through the above steps, we can eliminate variable
$x_2$, $u_2$ as well as three factors marked in red, and replace them with a new factor on $x_1$
marked in blue, with potential $x_1^TV_1x_1$ , which represents the marginalized cost on state
$x_1$.
&lt;!-- ************** BAYES NET ************** --&gt;
&lt;a id=&quot;sec:elim_bayes&quot;&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;h3 id=&quot;turning-into-a-bayes-network&quot;&gt;Turning into a Bayes Network&lt;/h3&gt;
  &lt;p&gt;By eliminating all the variables from right to left, we can get a Bayes network
as shown in &lt;a href=&quot;#fig_bayes_net&quot;&gt;Figure 5d&lt;/a&gt;. Everytime we eliminate an older state
and control, we simply repeat the steps in &lt;a href=&quot;#eliminate-a-state&quot;&gt;Eliminate a state&lt;/a&gt; and &lt;a href=&quot;#eliminate-a-control&quot;&gt;Eliminate a control&lt;/a&gt;: we express the
older state $x_{k+1}$ with the dynamics model, and express the control $u_k$ as
a function of state $x_k$, then generate a new factor on $x_k$ representing the
“cost-to-go” function $x_k^TV_kx_k$.&lt;/p&gt;

  &lt;p&gt;Eliminating a general state, $x_{k+1}$, and control $u_k$, we obtain the recurrence relations:
&lt;a name=&quot;eq:control_update_k&quot;&gt;&lt;/a&gt;
\[ \boxed{K_k = -(R+B^TV_{k+1}B)^{-1}B^TV_{k+1}A} \tag{9} \]
&lt;a name=&quot;eq:cost_update_k&quot;&gt;&lt;/a&gt;
\[ \boxed{V_k = Q+A^TV_{k+1}A - K_k^TB^TV_{k+1}A} \tag{10} \]
with $V_{T}=Q$ is the cost at the last time step.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;!-- scrollablecontent --&gt;
&lt;!-- ************************ END SCROLLABLE ELIMINATION DESCRIPTION ************************ --&gt;&lt;/p&gt;

&lt;h2 id=&quot;equivalence-to-the-ricatti-equation&quot;&gt;Equivalence to the Ricatti Equation&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear%E2%80%93quadratic_regulator#Finite-horizon,_discrete-time_LQR&quot;&gt;Wikipedia&lt;/a&gt;, the control law and cost function for LQR are given by&lt;/p&gt;

&lt;p&gt;\[ u_k = K_kx_k \]
&lt;a name=&quot;eq:control_update_k_ricatti&quot;&gt;&lt;/a&gt;
\[ K_k = -(R+B^TP_{k+1}B)^{-1}B^TP_{k+1}A \tag{11} \]
&lt;a name=&quot;eq:cost_update_k_ricatti&quot;&gt;&lt;/a&gt;
\[ P_k = Q+A^TP_{k+1}A - K_k^TB^TP_{k+1}A \tag{12} \]&lt;/p&gt;

&lt;p&gt;with $P_k$ commonly referred to as the solution to the dynamic Ricatti equation and $P_T=Q$ is the
value of the Ricatti function at the final time step.&lt;/p&gt;

&lt;p&gt;Note that &lt;a href=&quot;#eq:control_update_k_ricatti&quot;&gt;(11)&lt;/a&gt; and &lt;a href=&quot;#eq:cost_update_k_ricatti&quot;&gt;(12)&lt;/a&gt; correspond to
the same results as we derived in &lt;a href=&quot;#eq:control_update_k&quot;&gt;(9)&lt;/a&gt; and &lt;a href=&quot;#eq:cost_update_k&quot;&gt;(10)&lt;/a&gt;
respectively, where the Ricatti solutions, $P_k$, correspond to $V_k$ in our factor graph elimination.&lt;/p&gt;

&lt;h2 id=&quot;intuition&quot;&gt;Intuition&lt;/h2&gt;
&lt;p&gt;In our factor graph representation, it is becomes obvious that the dynamic Ricatti equation
solutions, $P_k$, correspond to the total cost at the state $x_k$ that will be accrued for the remainder
of the trajectory and control assuming optimal control after $x_k$.  Referred to as “cost-to-go”,
“return cost”, and “value function” by different literatures, we denote this cost as $\phi_k$, given by 
\[ \phi_k = x_k^TP_kx_k \]
This “cost-to-go” is depicted as a heatmap in &lt;a href=&quot;#LQR_example&quot;&gt;Figure 1&lt;/a&gt;.  From
&lt;a href=&quot;#eq:control_update_k&quot;&gt;(9)&lt;/a&gt;, the optimal control, $K_k$,
represents a balance between achieving a small “cost-to-go” next time step ($B^TV_{k+1}B$) and exerting a small
amount of control this time step ($R$).&lt;/p&gt;

&lt;h2 id=&quot;implementation-using-gtsam&quot;&gt;Implementation using GTSAM&lt;/h2&gt;
&lt;p&gt;We provide some 
modules and examples available to
&lt;a href=&quot;/assets/code_samples/lqr_control.zip&quot; download=&quot;&quot;&gt;download&lt;/a&gt;
that you can use in your
projects to:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Calculate the closed loop gain matrix, K, using GTSAM&lt;/li&gt;
  &lt;li&gt;Calculate the “cost-to-go” matrix, P (which is equivalent to the solutions to
the dynamic Ricatti equation), using GTSAM&lt;/li&gt;
  &lt;li&gt;Calculate the LQR solution for a non-zero, non-constant goal position, using GTSAM&lt;/li&gt;
  &lt;li&gt;Visualize the cost-to-go and how it relates to factor graphs and the Ricatti
equation&lt;/li&gt;
  &lt;li&gt;and more!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A brief example of the open-loop finite horizon LQR problem using
factor graphs is shown below:&lt;/p&gt;

&lt;div class=&quot;scrollablecontent&quot; style=&quot;overflow: auto; height:600px;&quot;&gt;

  &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solve_lqr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_time_steps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;'''Solves a discrete, finite horizon LQR problem given system dynamics in
    state space representation.
    Arguments:
        A, B: nxn state transition matrix and nxp control input matrix
        Q, R: nxn state cost matrix and pxp control cost matrix
        X0: initial state (n-vector)
        num_time_steps: number of time steps, T
    Returns:
        x_sol, u_sol: Txn array of states and Txp array of controls
    '''&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# noise models&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;PRIOR_NOISE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gtsam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noiseModel_Constrained&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;All&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;DYNAMICS_NOISE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gtsam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noiseModel_Constrained&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;All&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Q_NOISE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gtsam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dynamic_cast_noiseModel_Diagonal_noiseModel_Gaussian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;gtsam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noiseModel_Gaussian&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Information&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;R_NOISE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gtsam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dynamic_cast_noiseModel_Diagonal_noiseModel_Gaussian&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;gtsam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noiseModel_Gaussian&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Information&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# note: GTSAM 4.0.2 python wrapper doesn't have 'Information'&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# wrapper, use this instead if you are not on develop branch:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   `gtsam.noiseModel_Gaussian.SqrtInformation(np.sqrt(Q)))`&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# Create an empty Gaussian factor graph&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gtsam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GaussianFactorGraph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# Create the keys corresponding to unknown variables in the factor graph&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_time_steps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gtsam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gtsam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'u'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# set initial state as prior&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eye&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PRIOR_NOISE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# Add dynamics constraint as ternary factor&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;#   A.x1 + B.u1 - I.x2 = 0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_time_steps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eye&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DYNAMICS_NOISE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# Add cost functions as unary factors&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eye&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Q_NOISE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eye&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R_NOISE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;# Solve&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x_sol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_time_steps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;u_sol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_time_steps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_time_steps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x_sol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u_sol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x_sol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_sol&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;!-- ********************************** APPENDIX ********************************** --&gt;
&lt;h2 id=&quot;appendix&quot;&gt;Appendix&lt;/h2&gt;
&lt;h3 id=&quot;eliminate-u_1&quot;&gt;Eliminate $u_1$&lt;/h3&gt;
&lt;p&gt;Setting the derivative w.r.t. $u_1$ of the objective function, $\phi_1(x_1, u_1)$, in &lt;a href=&quot;#eq:potential_simplified&quot;&gt;(6)&lt;/a&gt; to zero:
\[ Ru_1 + B^TQ(Ax_1+Bu_1) = 0 \]
we solve to obtain the result shown in &lt;a href=&quot;#eq:control_law&quot;&gt;(7)&lt;/a&gt;:
\[ \begin{aligned} 
    &amp;amp; (R+B^TQB)u_1 + B^TQAx_1 = 0 \\ 
    &amp;amp; u_1 = -(R+B^TQB)^{-1}B^TQAx_1 
\end{aligned} \]&lt;/p&gt;

&lt;h3 id=&quot;marginalization-cost-on-x_1&quot;&gt;Marginalization Cost on $x_1$&lt;/h3&gt;
&lt;p&gt;By substituting &lt;a href=&quot;#eq:control_law&quot;&gt;(7)&lt;/a&gt; into &lt;a href=&quot;#eq:potential_simplified&quot;&gt;(6)&lt;/a&gt;, we have the updated
potential function as a function of only $x_1$:&lt;/p&gt;
&lt;div style=&quot;overflow:auto&quot;&gt;
  &lt;p&gt;\[ \begin{aligned} 
    \phi_1(x_1) &amp;amp;= x_1^T Q x_1 + (K_1x_1)^T RK_1x_1 + (Ax_1 + BKx_1)^T Q (Ax_1 + BKx_1) \\ 
    &amp;amp;= x_1^T(Q+ K_1^TRK_1 + A^TQA + K_1^TB^TQB - K_1^TB^TQA - A^TQBK_1)x_1  \\ 
    &amp;amp;= x_1^T[Q + A^TQA + K_1^T(R+B^TQB)K_1 - K_1^TB^TQA - A^TQBK_1]x_1 \\ 
    &amp;amp;= x_1^T(Q + A^TQA + A^TQBK_1 - K_1^TB^TQA - A^TQBK_1)x_1 \\ 
    &amp;amp;= x_1^T(Q + A^TQA - K_1^TB^TQA)x_1 
\end{aligned} \]&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;least-squares-implementation-in-gtsam&quot;&gt;Least Squares Implementation in GTSAM&lt;/h3&gt;
&lt;p&gt;GTSAM can be specified to use either of two methods for solving the least squares problems that
appear in eliminating factor graphs: Cholesky Factorization or QR Factorization.  We
will find that both arrive at the same solution matching the dynamic Ricatti equation solution.&lt;/p&gt;
&lt;h4 id=&quot;cholesky-factorization&quot;&gt;Cholesky Factorization&lt;/h4&gt;
&lt;p&gt;We have established that the cost optimization in the LQR problem can be expressed as a least
squares problem $\argmin\limits_x||Ax-b||_2^2$ where ${x=[x_2;u_1;x_1;u_0;x_0]}$ is the vertical
concatenation of all state and control vectors, $A$ is a matrix representing quadratic costs, and
$b=0$ for the case of optimizing both control and state cost towards 0.&lt;/p&gt;

&lt;p&gt;To solve the linear least squares problem $\argmin\limits_x||Ax-b||_2^2$, we can reformulate the
problem as the equivalent linear equation $A^TAx=A^Tb$. Cholesky factorization computes a factorization on $A^TA$ such that
$A^TA=R^TR$ thereby allowing solving by back-substitution.
Instead of considering the full $A^TA$ matrix, for demonstrative purposes we can consider just a
single &lt;em&gt;clique&lt;/em&gt;, as it is implemented in GTSAM for computational reasons.  A clique is a set of
variables which are fully connected. In each clique, GTSAM first performs variable elimination with
the strict constraints to convert the constrained optimization problem into an unconstrained one.
Then, GTSAM performs Cholesky factorization on rest of the variables. For the clique circled in red
in &lt;a href=&quot;#fig:clique&quot;&gt;Figure 6&lt;/a&gt;, we first eliminate $x_2$ using the dynamics constraint to obtain our least
squares clique formulation: ${x=[u_1;x_1]}$, $b=0$, and $A$ and $A^TA$ are given by&lt;/p&gt;

&lt;p&gt;\[ \begin{aligned} 
    A= 
    \begin{bmatrix} 
      Q^{\frac{1}{2}}B &amp;amp; Q^{\frac{1}{2}}A \\ 
      R^{\frac{1}{2}} &amp;amp; \\ 
      &amp;amp; Q^{\frac{1}{2}} 
    \end{bmatrix} 
\end{aligned} \]
\[ \begin{aligned} 
    A^TA= 
    \begin{bmatrix} 
      R + B^TQB &amp;amp; B^TQA \\ 
      A^TQB &amp;amp; Q+A^TQA 
    \end{bmatrix} 
\end{aligned} \]
Applying block Cholesky decomposition on the matrix, we have
\[ \begin{aligned} 
    R = 
    \begin{bmatrix} 
      D_1^{\frac{1}{2}} &amp;amp; -D_1^{\frac{1}{2}}K_1 \\ 
      0 &amp;amp; V_1^{\frac{1}{2}} 
    \end{bmatrix} 
\end{aligned} \]&lt;/p&gt;

&lt;!-- plain table for formatting purposes --&gt;
&lt;style&gt;
table, caption, tbody, tfoot, thead, table tr, table th, table tr:nth-child(even), td {
    margin: 0;
    padding: 0;
    border: 0;
    outline: 0;
    font-size: 100%;
    font-weight: normal;
    vertical-align: baseline;
    background: transparent;
    background-color: transparent;
}
table th {
    padding: 3px;
}
&lt;/style&gt;

&lt;!-- &quot;where D = ..., K = ..., V = ...&quot; --&gt;
&lt;div style=&quot;overflow: auto&quot;&gt;
&lt;table style=&quot;width:3.8in;&quot;&gt;
    &lt;tr&gt;
        &lt;th&gt;where&lt;/th&gt;&lt;th&gt;$D_1$&lt;/th&gt;&lt;th&gt;$=$&lt;/th&gt;&lt;th&gt;$R + B^TQB$&lt;/th&gt;
    &lt;/tr&gt;&lt;tr&gt;
        &lt;th&gt;&lt;/th&gt;&lt;th&gt;$K_1$&lt;/th&gt;&lt;th&gt;$=$&lt;/th&gt;&lt;th&gt;$-(R + B^TQB)^{-1}B^TQA$&lt;/th&gt;
    &lt;/tr&gt;&lt;tr&gt;
        &lt;th&gt;&lt;/th&gt;&lt;th&gt;$V_1$&lt;/th&gt;&lt;th&gt;$=$&lt;/th&gt;&lt;th&gt;$Q + A^TQA - K_1^TD_1^{T/2}D_1^{1/2}K_1$&lt;/th&gt;
    &lt;/tr&gt;&lt;tr&gt;
        &lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;$=$&lt;/th&gt;&lt;th&gt;$Q + A^TQA - K_1^TB^TQA$&lt;/th&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;which can be verified by multiplying out $R^TR$.  It is now evident that the top block row of $R$
gives the control law (i.e. $D_1^{1/2}u_1 - D_1^{1/2}K_1x_1 = 0$) and the bottom block row gives the
new “cost-to-go” for the next clique.&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;fig:clique&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/lqr_control/VE/cliq1a.png&quot; alt=&quot;Single clique in LQR factor graph.&quot; /&gt;
    &lt;figcaption&gt;&lt;b&gt;Figure 6&lt;/b&gt; A single clique in the LQR factor graph formulation is circled in red.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;qr-factorization&quot;&gt;QR Factorization&lt;/h4&gt;
&lt;p&gt;The process is illustrated in &lt;a href=&quot;#fig:qr_elim&quot;&gt;Figure 7&lt;/a&gt; where the noise matrices and elimination
matrices are shown with the corresponding states of the graph.  The noise matrix (NM) is $0$ for a
hard constraint and $I$ for a minimization objective.  The elimination matrix is formatted as an
augmented matrix $[A|b]$ for the linear least squares problem $\argmin\limits_x||Ax-b||_2^2$
with ${x=[x_2;u_1;x_1;u_0;x_0]}$ is the vertical concatenation of all state and control vectors.&lt;/p&gt;

&lt;!-- ************************ QR block elimination ************************ --&gt;
&lt;!-- Slideshow container, based on https://www.w3schools.com/howto/howto_js_slideshow.asp --&gt;
&lt;p&gt;&lt;a name=&quot;fig:qr_elim&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;slideshow-container&quot; style=&quot;min-height:3in;&quot;&gt;
  &lt;div class=&quot;mySlides 1&quot; style=&quot;text-align: center;&quot;&gt;
      &lt;figure class=&quot;center&quot; style=&quot;width:75%&quot;&gt;
&lt;div align=&quot;left&quot; style=&quot;width:100%; height:2.2in; overflow:auto&quot;&gt;
        &lt;p&gt;\( \begin{array}{cc} 
    \text{NM} &amp;amp; \text{Elimination Matrix} \\ 
    \begin{bmatrix} 
        I\\ 
        0\\ 
        I\\ 
        I\\ 
        0\\ 
        I\\ 
        I
    \end{bmatrix} &amp;amp; 
    \left[ \begin{array}{ccccc|c} 
        Q^{1/2} &amp;amp;   &amp;amp;       &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
        I &amp;amp; -B      &amp;amp; -A    &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
          &amp;amp; R^{1/2} &amp;amp;       &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;         &amp;amp; Q^{1/2}&amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;         &amp;amp; I     &amp;amp; -B    &amp;amp; -A    &amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp; R^{1/2}&amp;amp;      &amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp;       &amp;amp; Q^{1/2}&amp;amp; 0 
    \end{array} \right]
    \end{array} \)&lt;/p&gt;
      &lt;/div&gt;
        &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg0.png&quot; alt=&quot;factor graph partially eliminated&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 7a&lt;/b&gt; Initial factor graph and elimination matrix&lt;/figcaption&gt;
      &lt;/figure&gt;
  &lt;/div&gt;
  &lt;div class=&quot;mySlides 1&quot; style=&quot;text-align: center;&quot;&gt;
      &lt;figure class=&quot;center&quot; style=&quot;width:75%&quot;&gt;
&lt;div align=&quot;left&quot; style=&quot;width:100%; height:2.2in; overflow:auto&quot;&gt;
        &lt;p&gt;\( \begin{array}{cc} 
    \text{NM} &amp;amp; \text{Elimination Matrix} \\ 
    \begin{bmatrix} 
        I\\ 
        0\\ 
        I\\ 
        I\\ 
        0\\ 
        I\\ 
        I
    \end{bmatrix} &amp;amp; 
    \left[ \begin{array}{ccccc|c} 
        \color{red} Q^{1/2} &amp;amp;   &amp;amp;       &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
        \color{red} I &amp;amp; \color{red} -B      &amp;amp; \color{red} -A    &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
          &amp;amp; R^{1/2} &amp;amp;       &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;         &amp;amp; Q^{1/2}&amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;         &amp;amp; I     &amp;amp; -B    &amp;amp; -A    &amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp; R^{1/2}&amp;amp;      &amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp;       &amp;amp; Q^{1/2}&amp;amp; 0 
    \end{array} \right]
    \end{array} \)&lt;/p&gt;
      &lt;/div&gt;
        &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg1.png&quot; alt=&quot;factor graph partially eliminated&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 7b&lt;/b&gt; Eliminate $x_2$: the two factors to eliminate are highlighted in red&lt;/figcaption&gt;
      &lt;/figure&gt;
  &lt;/div&gt;

  &lt;div class=&quot;mySlides 1&quot; style=&quot;text-align: center;&quot;&gt;
      &lt;figure class=&quot;center&quot; style=&quot;width:75%&quot;&gt;
&lt;div align=&quot;left&quot; style=&quot;width:100%; height:2.2in; overflow:auto&quot;&gt;
        &lt;p&gt;\( \begin{array}{cc} 
    \text{NM} &amp;amp; \text{Elimination Matrix} \\ 
    \begin{bmatrix} 
        0\\ 
        I\\ 
        I\\ 
        I\\ 
        0\\ 
        I\\ 
        I\\ 
    \end{bmatrix} &amp;amp; 
    \left[ \begin{array}{c:cccc|c} 
        I &amp;amp; -B      &amp;amp; -A    &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
        \hdashline 
          &amp;amp; \color{blue} Q^{1/2}B &amp;amp; \color{blue} Q^{1/2}A&amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          &amp;amp; R^{1/2} &amp;amp;       &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;                     &amp;amp; Q^{1/2}&amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;                     &amp;amp; I     &amp;amp; -B    &amp;amp; -A    &amp;amp; 0\\ 
          &amp;amp;                     &amp;amp;       &amp;amp; R^{1/2}&amp;amp;      &amp;amp; 0\\ 
          &amp;amp;                     &amp;amp;       &amp;amp;       &amp;amp; Q^{1/2}&amp;amp; 0 
    \end{array} \right]
    \end{array} \)&lt;/p&gt;
      &lt;/div&gt;
        &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg2.png&quot; alt=&quot;factor graph partially eliminated&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 7c&lt;/b&gt; Eliminated $x_2$: the resulting binary cost factor is highlighted in blue&lt;/figcaption&gt;
      &lt;/figure&gt;
  &lt;/div&gt;

  &lt;div class=&quot;mySlides 1&quot; style=&quot;text-align: center;&quot;&gt;
      &lt;figure class=&quot;center&quot; style=&quot;width:75%&quot;&gt;
&lt;div align=&quot;left&quot; style=&quot;width:100%; height:2.2in; overflow:auto&quot;&gt;
        &lt;p&gt;\( \begin{array}{cc} 
    \text{NM} &amp;amp; \text{Elimination Matrix} \\ 
    \begin{bmatrix} 
        0\\ 
        I\\ 
        I\\ 
        I\\ 
        0\\ 
        I\\ 
        I\\ 
    \end{bmatrix} &amp;amp; 
    \left[ \begin{array}{c:cccc|c} 
        I &amp;amp; -B      &amp;amp; -A    &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
        \hdashline 
          &amp;amp; \color{red} Q^{1/2}B &amp;amp; \color{red} Q^{1/2}A&amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          &amp;amp; \color{red} R^{1/2} &amp;amp;       &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;                     &amp;amp; \color{red} Q^{1/2}&amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;                     &amp;amp; I     &amp;amp; -B    &amp;amp; -A    &amp;amp; 0\\ 
          &amp;amp;                     &amp;amp;       &amp;amp; R^{1/2}&amp;amp;      &amp;amp; 0\\ 
          &amp;amp;                     &amp;amp;       &amp;amp;       &amp;amp; Q^{1/2}&amp;amp; 0 
    \end{array} \right]
    \end{array} \)&lt;/p&gt;
      &lt;/div&gt;
        &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg3.png&quot; alt=&quot;factor graph partially eliminated&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 7d&lt;/b&gt; Eliminate $u_1$: the three factors to eliminate are highlighted in red&lt;/figcaption&gt;
      &lt;/figure&gt;
  &lt;/div&gt;

  &lt;div class=&quot;mySlides 1&quot; style=&quot;text-align: center;&quot;&gt;
      &lt;figure class=&quot;center&quot; style=&quot;width:75%&quot;&gt;
&lt;div align=&quot;left&quot; style=&quot;width:100%; height:2.2in; overflow:auto&quot;&gt;
        &lt;p&gt;\( \begin{array}{cc} 
    \text{NM} &amp;amp; \text{Elimination Matrix} \\ 
    \begin{bmatrix} 
        0\\ 
        I\\ 
        I\\ 
        0\\ 
        I\\ 
        I\\ 
    \end{bmatrix} &amp;amp; 
    \left[ \begin{array}{cc:ccc|c} 
        I &amp;amp; -B      &amp;amp; -A    &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
          &amp;amp; D_1^{1/2} &amp;amp; -D_1^{1/2}K_1 &amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          \hdashline 
          &amp;amp;         &amp;amp; \color{blue} P_1^{1/2} &amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;         &amp;amp; I     &amp;amp; -B    &amp;amp; -A    &amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp; R^{1/2}&amp;amp;      &amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp;       &amp;amp; Q^{1/2}&amp;amp; 0 
    \end{array} \right]
    \end{array} \)&lt;/p&gt;
      &lt;/div&gt;
        &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg4.png&quot; alt=&quot;factor graph partially eliminated&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 7e&lt;/b&gt; Eliminated $u_1$: the resulting unary cost factor on $x_1$ is shown in blue&lt;/figcaption&gt;
      &lt;/figure&gt;
  &lt;/div&gt;

  &lt;div class=&quot;mySlides 1&quot; style=&quot;text-align: center;&quot;&gt;
      &lt;figure class=&quot;center&quot; style=&quot;width:75%&quot;&gt;
&lt;div align=&quot;left&quot; style=&quot;width:100%; height:2.2in; overflow:auto&quot;&gt;
        &lt;p&gt;\( \begin{array}{cc} 
    \text{NM} &amp;amp; \text{Elimination Matrix} \\ 
    \begin{bmatrix} 
        0\\ 
        I\\ 
        I\\ 
        0\\ 
        I\\ 
        I\\ 
    \end{bmatrix} &amp;amp; 
    \left[ \begin{array}{cc:ccc|c} 
        I &amp;amp; -B      &amp;amp; -A    &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
          &amp;amp; D_1^{1/2} &amp;amp; -D_1^{1/2}K_1 &amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          \hdashline 
          &amp;amp;         &amp;amp; \color{red} P_1^{1/2} &amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;         &amp;amp; \color{red} I     &amp;amp; \color{red} -B    &amp;amp; \color{red} -A    &amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp; R^{1/2}&amp;amp;      &amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp;       &amp;amp; Q^{1/2}&amp;amp; 0 
    \end{array} \right]
    \end{array} \)&lt;/p&gt;
      &lt;/div&gt;
        &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg5.png&quot; alt=&quot;factor graph partially eliminated&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 7f&lt;/b&gt; Eliminate $x_1$: the two factors to eliminate are highlighted in red&lt;/figcaption&gt;
      &lt;/figure&gt;
  &lt;/div&gt;

  &lt;div class=&quot;mySlides 1&quot; style=&quot;text-align: center;&quot;&gt;
      &lt;figure class=&quot;center&quot; style=&quot;width:75%&quot;&gt;
&lt;div align=&quot;left&quot; style=&quot;width:100%; height:2.2in; overflow:auto&quot;&gt;
        &lt;p&gt;\( \begin{array}{cc} 
    \text{NM} &amp;amp; \text{Elimination Matrix} \\ 
    \begin{bmatrix} 
        0\\ 
        I\\ 
        0\\ 
        I\\ 
        I\\ 
        I\\ 
    \end{bmatrix} &amp;amp; 
    \left[ \begin{array}{ccc:cc|c} 
        I &amp;amp; -B      &amp;amp; -A    &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
          &amp;amp; D_1^{1/2} &amp;amp; -D_1^{1/2}K_1&amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;         &amp;amp; I     &amp;amp; -B    &amp;amp; -A    &amp;amp; 0\\ 
          \hdashline 
          &amp;amp;         &amp;amp;       &amp;amp;\color{blue} P_1^{1/2}B &amp;amp;\color{blue} P_1^{1/2}A&amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp; R^{1/2}&amp;amp;      &amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp;       &amp;amp; Q^{1/2}&amp;amp; 0 
    \end{array} \right]
    \end{array} \)&lt;/p&gt;
      &lt;/div&gt;
        &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg6.png&quot; alt=&quot;factor graph partially eliminated&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 7g&lt;/b&gt; Eliminated $x_1$: the resulting binary cost factor is shown in blue&lt;/figcaption&gt;
      &lt;/figure&gt;
  &lt;/div&gt;

  &lt;div class=&quot;mySlides 1&quot; style=&quot;text-align: center;&quot;&gt;
      &lt;figure class=&quot;center&quot; style=&quot;width:75%&quot;&gt;
&lt;div align=&quot;left&quot; style=&quot;width:100%; height:2.2in; overflow:auto&quot;&gt;
        &lt;p&gt;\( \begin{array}{cc} 
    \text{NM} &amp;amp; \text{Elimination Matrix} \\ 
    \begin{bmatrix} 
        0\\ 
        I\\ 
        0\\ 
        I\\ 
        I\\ 
        I\\ 
    \end{bmatrix} &amp;amp; 
    \left[ \begin{array}{ccc:cc|c} 
        I &amp;amp; -B      &amp;amp; -A    &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
          &amp;amp; D_1^{1/2} &amp;amp; -D_1^{1/2}K_1&amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;         &amp;amp; I     &amp;amp; -B    &amp;amp; -A    &amp;amp; 0\\ 
          \hdashline 
          &amp;amp;         &amp;amp;       &amp;amp;\color{red} P_1^{1/2}B &amp;amp;\color{red} P_1^{1/2}A&amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp;\color{red} R^{1/2}&amp;amp;      &amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp;       &amp;amp;\color{red} Q^{1/2}&amp;amp; 0 
    \end{array} \right]
    \end{array} \)&lt;/p&gt;
      &lt;/div&gt;
        &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg7.png&quot; alt=&quot;factor graph partially eliminated&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 7h&lt;/b&gt; Eliminate $u_0$: the three cost factors to combine are shown in red&lt;/figcaption&gt;
      &lt;/figure&gt;
  &lt;/div&gt;

  &lt;div class=&quot;mySlides 1&quot; style=&quot;text-align: center;&quot;&gt;
      &lt;figure class=&quot;center&quot; style=&quot;width:75%&quot;&gt;
&lt;div align=&quot;left&quot; style=&quot;width:100%; height:2.2in; overflow:auto&quot;&gt;
        &lt;p&gt;\( \begin{array}{cc} 
    \text{NM} &amp;amp; \text{Elimination Matrix} \\ 
    \begin{bmatrix} 
        0\\ 
        I\\ 
        0\\ 
        I\\ 
        I\\ 
    \end{bmatrix} &amp;amp; 
    \left[ \begin{array}{cccc:c|c} 
        I &amp;amp; -B      &amp;amp; -A    &amp;amp;       &amp;amp;       &amp;amp; 0\\ 
          &amp;amp; D_1^{1/2} &amp;amp; -D_1^{1/2}K_1 &amp;amp;      &amp;amp;       &amp;amp; 0\\ 
          &amp;amp;         &amp;amp; I     &amp;amp; -B    &amp;amp; -A    &amp;amp; 0\\ 
          &amp;amp;         &amp;amp;       &amp;amp; D_0^{1/2}  &amp;amp; -D_0^{1/2}K_0 &amp;amp; 0\\ 
          \hdashline 
          &amp;amp;         &amp;amp;       &amp;amp;       &amp;amp; \color{blue} P_0^{1/2}   &amp;amp; 0
    \end{array} \right]
    \end{array} \)&lt;/p&gt;
      &lt;/div&gt;
        &lt;img src=&quot;/assets/images/lqr_control/elimination_steps/fg8.png&quot; alt=&quot;factor graph partially eliminated&quot; /&gt;
        &lt;figcaption&gt;&lt;b&gt;Figure 7i&lt;/b&gt; Final result: after eliminating $u_0$, the elimination matrix is upper-triangular and we can read off the control laws.&lt;/figcaption&gt;
      &lt;/figure&gt;
  &lt;/div&gt;
  
  &lt;!-- Next and previous buttons --&gt;
  &lt;a class=&quot;prev&quot; onclick=&quot;plusSlides(-1,1)&quot;&gt;&amp;#10094;&lt;/a&gt;
  &lt;a class=&quot;next&quot; onclick=&quot;plusSlides(1,1)&quot;&gt;&amp;#10095;&lt;/a&gt;

&lt;/div&gt;
&lt;p&gt;&lt;!-- slideshow-container --&gt;&lt;/p&gt;

&lt;!-- The dots/circles --&gt;
&lt;div style=&quot;text-align:center&quot;&gt;
  &lt;span class=&quot;dot 1&quot; onclick=&quot;currentSlide(1,1)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 1&quot; onclick=&quot;currentSlide(2,1)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 1&quot; onclick=&quot;currentSlide(3,1)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 1&quot; onclick=&quot;currentSlide(4,1)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 1&quot; onclick=&quot;currentSlide(5,1)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 1&quot; onclick=&quot;currentSlide(6,1)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 1&quot; onclick=&quot;currentSlide(7,1)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 1&quot; onclick=&quot;currentSlide(8,1)&quot;&gt;&lt;/span&gt;
  &lt;span class=&quot;dot 1&quot; onclick=&quot;currentSlide(9,1)&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;overflow: auto&quot;&gt;
&lt;table style=&quot;width:6.1in; margin: 0 auto;&quot;&gt;
    &lt;tr&gt;
        &lt;th&gt;where&lt;/th&gt;&lt;th&gt;$P_{t}$&lt;/th&gt;&lt;th&gt;$=$&lt;/th&gt;&lt;th&gt;$Q + A^TP_{t+1}A - K_t^TB^TP_{t+1}A$&lt;/th&gt;&lt;th&gt;($P_2=Q$)&lt;/th&gt;
    &lt;/tr&gt;&lt;tr&gt;
        &lt;th&gt;&lt;/th&gt;&lt;th&gt;$D_{t}$&lt;/th&gt;&lt;th&gt;$=$&lt;/th&gt;&lt;th&gt;$R + B^TP_{t+1}B$&lt;/th&gt;
    &lt;/tr&gt;&lt;tr&gt;
        &lt;th&gt;&lt;/th&gt;&lt;th&gt;$K_t$&lt;/th&gt;&lt;th&gt;$=$&lt;/th&gt;&lt;th&gt;$-D_{t}^{-1/2}(R + B^TP_{t+1}B)^{-T/2}B^TP_{t+1}A$&lt;/th&gt;
    &lt;/tr&gt;&lt;tr&gt;
        &lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;$=$&lt;/th&gt;&lt;th&gt;$-(R + B^TP_{t+1}B)^{-1}B^TP_{t+1}A$&lt;/th&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;!-- ************************ end QR block elimination ************************ --&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Note that all $b_i=0$ in the augmented matrix for the LQR problem of finding minimal control to
reach state $0$, but simply changing values of $b_i$ can intuitively extend GTSAM to solve
LQR problems whose objectives are to reach different states or even trajectories.&lt;/p&gt;

&lt;p&gt;The recursive expressions for $P$ and $V$ are derived from block QR Factorization.
However, block QR factorization is non-trivial to follow so, for demonstrative purposes, we can also
find their forms algebraically using the “completing the square” technique.  Taking, for example,
the elimination of $u_0$ ,&lt;/p&gt;

&lt;div style=&quot;overflow:auto&quot;&gt;
  &lt;p&gt;\[ \begin{aligned} \scriptstyle 
    J(u_0, x_0) &amp;amp; \scriptstyle=~ || P_1^{1/2}Bu_0 ~+~ P_1^{1/2}Ax_0||^2_2 ~+~ ||R^{1/2}u_0||^2_2 \qquad+ ||Q^{1/2}x_0||^2_2 \\ 
        &amp;amp; \scriptstyle=~ u_0^T(B^TP_1B+R)u_0 ~+~ 2u_0^TB^TP_1Ax_0 ~+~ x_0^TA^TP_1Ax_0 \qquad+ x^TQx \\ 
        &amp;amp; \scriptstyle=~ u_0^T(B^TP_1B+R)u_0 ~+~ 2u_0^T(B^TP_1B+R)^{1/2}(B^TP_1B+R)^{-1/2}B^TP_1Ax_0 ~+~ x_0^TA^TP_1Ax_0 \qquad+ x_0^TQx_0 \\ 
        &amp;amp; \scriptstyle=~ ||(B^TP_1B+R)^{1/2}u_0 ~+~ (B^TP_1B+R)^{-1/2}B^TP_1Ax_0||^2_2 ~-~ x_0^T(A^TP_1^TB(B^TP_1B+R)^{-T}B^TP_1A)x_0 ~+~ x_0^TA^TP_1Ax_0 ~+~ x^TQx  \\ 
        &amp;amp; \scriptstyle=~ ||(B^TP_1B+R)^{1/2}u_0 ~+~ (B^TP_1B+R)^{-1/2}B^TP_1Ax_0||_2^2 ~+~ ||(Q ~+~ A^TP_1A)^{1/2}x_0 ~-~ A^TP_1^TB(B^TP_1B+R)^{-T}B^TP_1A||_2^2  \\ 
        &amp;amp; \scriptstyle=~ ||(B^TP_1B+R)^{1/2}u_0 ~+~ (B^TP_1B+R)^{-1/2}B^TP_1Ax_0||_2^2 ~+~ ||(Q ~+~ A^TP_1A ~-~ K_0^TB^TP_1A)^{1/2}x_0||_2^2 \\ 
        &amp;amp; \scriptstyle=~ ||V_{0,0}u_0 ~+~ V_{0,1}x_0||_2^2 ~+~ ||P_0^{1/2}x_0||_2^2 
\end{aligned} \]&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;final-symbolic-expressions-of-factor-graph-evaluation&quot;&gt;Final Symbolic Expressions of Factor Graph Evaluation&lt;/h3&gt;
&lt;p&gt;In the above solution, we have
\[ \begin{aligned} 
K_1 &amp;amp;= -(R+B^TQB)^{-1}B^TQA\\ 
P_1 &amp;amp;= Q+A^TQA + A^TQBK_1\\ 
K_0 &amp;amp;= -(R+B^TV_1B)^{-1}B^TV_1A\\ 
P_0 &amp;amp;= Q + A^T V_1 A + A^T V_1 B K_0
\end{aligned} \]&lt;/p&gt;

&lt;p&gt;In general, the above factor graph and solution method can be expanded for an arbitrary number of time steps, $T$, arising in the iterative equations
\[ \begin{aligned} 
    V_T &amp;amp;= Q \\ 
    K_t &amp;amp;= -( R + B^T V_{t+1} B )^{-1} B^T V_{t+1} A \\ 
    P_t &amp;amp;= Q + A^T V_{t+1} A + A^T V_{t+1} B K_t 
\end{aligned} \]
and
\[ \begin{aligned} 
    u_t &amp;amp;= K_t x_t
\end{aligned} \]
which match the traditional algorithm using the Ricatti Equation for solving the finite-horizon discrete-time LQR problem.  As the number
of time steps grows, the solution for $V_0$ approaches the stationary solution to the algebraic
Ricatti equation and the solution for $K_0$ approaches the solution to the infinite-horizon
discrete-time LQR problem.&lt;/p&gt;

&lt;!-- **************** JAVASCRIPT FOR SLIDESHOWS **************** --&gt;
&lt;script&gt;
    var slideIndex = [1,1];
    showSlides(slideIndex[0], 0);
    showSlides(slideIndex[1], 1);

    // Next/previous controls
    function plusSlides(n, which) {
        showSlides(slideIndex[which] += n, which);
    }

    // Thumbnail image controls
    function currentSlide(n, which) {
        showSlides(slideIndex[which] = n, which);
    }

    // change image/slide
    function showSlides(n, which, triggeredByScroll) {
        var i;
        var slides = document.getElementsByClassName(&quot;mySlides &quot;+which);
        var dots = document.getElementsByClassName(&quot;dot &quot;+which);
        if (n &gt; slides.length) {slideIndex[which] = 1}
        if (n &lt; 1) {slideIndex[which] = slides.length}
        for (i = 0; i &lt; slides.length; i++) {
            slides[i].style.display = &quot;none&quot;;
        }
        for (i = 0; i &lt; dots.length; i++) {
            dots[i].className = dots[i].className.replace(&quot; active&quot;, &quot;&quot;);
        }
        slides[slideIndex[which]-1].style.display = &quot;block&quot;;
        dots[slideIndex[which]-1].className += &quot; active&quot;;

        if (which==1){
            return
        }

        // when image changes, also scroll to the correct subsection in &quot;Variable Elimination&quot;
        var scrollable = document.getElementById(&quot;sec:elim_scrollable&quot;);
        var scrollLoc_state = document.getElementById(&quot;sec:elim_state&quot;).offsetTop - scrollable.offsetTop;
        var scrollLoc_ctrl = document.getElementById(&quot;sec:elim_ctrl&quot;).offsetTop - scrollable.offsetTop;
        var scrollLoc_bayes = document.getElementById(&quot;sec:elim_bayes&quot;).offsetTop - scrollable.offsetTop;
        var scroll_cur = scrollable.scrollTop;
        var scrollLoc;
        switch(slideIndex[which]) {
            case 1:
            case 2:
                return; // never force scroll up, only force scroll down
                // scrollLoc = scrollLoc_state;
                // break;
            case 3:
            case 4:
                if (scroll_cur &gt;= scrollLoc_ctrl) {return;}
                scrollLoc = scrollLoc_ctrl;
                break;
            case 5:
            case 6:
            case 7:
            case 8:
                if (scroll_cur &gt;= scrollLoc_bayes) {return;}
                scrollLoc = scrollLoc_bayes;
                break;
        }
        if (typeof triggeredByScroll === 'undefined') {
            scrollable.scrollTo(0, scrollLoc);
        }
    }

    // when scrolling through subsections in &quot;Variable Elimination&quot;, also change the image to correspond
    document.getElementById(&quot;sec:elim_scrollable&quot;).addEventListener(&quot;scroll&quot;, function (event) {
        var scrollable = document.getElementById(&quot;sec:elim_scrollable&quot;);
        var scrollLoc_state = document.getElementById(&quot;sec:elim_state&quot;).offsetTop - scrollable.offsetTop;
        var scrollLoc_ctrl = document.getElementById(&quot;sec:elim_ctrl&quot;).offsetTop - scrollable.offsetTop;
        var scrollLoc_bayes = document.getElementById(&quot;sec:elim_bayes&quot;).offsetTop - scrollable.offsetTop;
        
        var scroll = this.scrollTop;
        if (scroll &lt; scrollLoc_ctrl) {
            if (slideIndex[0] &gt; 2) {showSlides(slideIndex[0]=1, 0, true)}
        }
        else if ((scroll &lt; scrollLoc_bayes) &amp;&amp; (scroll &lt; (scrollable.scrollHeight - scrollable.offsetHeight))) {
            if ((slideIndex[0] &lt; 3) || (slideIndex[0] &gt; 4)) {showSlides(slideIndex[0]=3, 0, true)}
        }
        else {
            if ((slideIndex[0] &lt; 5)) {showSlides(slideIndex[0]=5, 0, true)}
        }
    });
&lt;/script&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Look Ma, No RANSAC</title><link href="http://localhost:4000/2019/09/20/robust-noise-model.html" rel="alternate" type="text/html" title="Look Ma, No RANSAC" /><published>2019-09-20T00:00:00-04:00</published><updated>2019-09-20T00:00:00-04:00</updated><id>http://localhost:4000/2019/09/20/robust-noise-model</id><content type="html" xml:base="http://localhost:4000/2019/09/20/robust-noise-model.html">&lt;p&gt;Author: Varun Agrawal&lt;br /&gt;
Website: &lt;a href=&quot;https://varunagrawal.github.io&quot;&gt;varunagrawal.github.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(&lt;em&gt;&lt;strong&gt;Psst&lt;/strong&gt;, be sure to clone/download GTSAM 4.0.2 which resolves a bug in the Huber model discussed below, for correct weight behavior&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;figure class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/robust_estimators/se2_matches.png&quot; alt=&quot;Matches between books&quot; /&gt;
  &lt;figcaption&gt;&lt;b&gt;Figure 1&lt;/b&gt; Two books on a plane separated by an SE(2) transform, and some manually selected feature matches between them. There are some clearly incorrect matches, which are &lt;b&gt;outliers&lt;/b&gt;.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Robust error models are powerful tools for supplementing parameter estimation algorithms with the added capabilities of modeling outliers. Parameter estimation is a fundamental tool used in many fields, especially in perception and robotics, and thus performing robust parameter estimation across a wide range of applications and scenarios is crucial to strong performance for many applications. This necessitates the need to manage outliers in our measurements, and robust error models provide us the means to do so. Robust error models are amenable to easy plug-and-play use in pre-existing optimization frameworks, requiring minimal changes to existing pipelines.&lt;/p&gt;

&lt;p&gt;Using robust error models can even obviate the need for more complex, non-deterministic algorithms such as Random Sample Consensus (a.k.a. RANSAC), a fundamental tool for parameter estimation in many a roboticist’s toolbox for years. While RANSAC has proven to work well in practice, it might need a high number of runs to converge to a good solution. Robust error models are conceptually easy and intuitive and can be used by themselves or in conjunction with RANSAC.&lt;/p&gt;

&lt;p&gt;In this blog post, we demonstrate the capabilities of robust error models which downweigh outliers to provide better estimates of the parameters of interest. To illustrate the benefits of robust error models, take a look at &lt;strong&gt;Figure 1&lt;/strong&gt;. We show two books next to each other, transformed by an $SE(2)$ transform, with some manually labeled point matches between the two books. We have added some outliers to more realistically model the problem.
As we will see later in the post, the estimates from RANSAC and a robust estimation procedure are quite similar, even though the ratio of inliers to outliers is $2:1$.&lt;/p&gt;

&lt;h2 id=&quot;parameter-estimation---a-short-tutorial&quot;&gt;Parameter Estimation - A Short Tutorial&lt;/h2&gt;

&lt;p&gt;We begin by reviewing techniques for parameter estimation as outlined by the &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/RR-2676.pdf&quot;&gt;tutorial by Zhengyou Zhang&lt;/a&gt;, as applied to our $SE(2)$. Given some matches ${(s,s’)}$ between the two images, we want to estimate the the $SE(2)$ parameters $\theta$ that transform a feature $s$ in the first image to a feature $s’$ in the  second image:&lt;/p&gt;

&lt;p&gt;\[ s’ = f(\theta ; s) \]&lt;/p&gt;

&lt;p&gt;Of course, this generalizes to other transformations, including 3D-2D problems. This is a ubiquitous problem seen in multiple domains of perception and robotics and is referred to as &lt;strong&gt;parameter estimation&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A standard framework to estimate the parameters is via the Least-Squares formulation. We usually have many more observations than we have parameters, i.e., the problem is now overdetermined. To handle this, we minimize the sum of square &lt;strong&gt;residuals&lt;/strong&gt; $f(\theta ; s_i) - s’_i$, for $i\in1\ldots N$:&lt;/p&gt;

&lt;p&gt;\[ E_{LS}(\theta) =  \sum_i \vert\vert f(\theta ; s_i) - s’_i \vert\vert^2 \]&lt;/p&gt;

&lt;p&gt;which we refer to as &lt;strong&gt;the cost function&lt;/strong&gt; or &lt;strong&gt;the objective function&lt;/strong&gt;.
In the case of $SE(2)$ the parameters $\theta$ should be some parameterization of a transformation matrix, having three degrees of freedom (DOF). A simple way to accomplish this is to have $\theta=(x,y,\alpha)$.&lt;/p&gt;

&lt;p&gt;Our measurement functions are generally non-linear, and hence we need to linearize the measurement function around an estimate of $\theta$. GTSAM will iteratively do so via optimization procedures such as Gauss-Newton, Levenberg-Marquardt, or Dogleg. Linearization is done via the &lt;strong&gt;Taylor expansion&lt;/strong&gt; around a linearization point $\theta_0$:&lt;/p&gt;

&lt;p&gt;\[ f(\theta + \Delta\theta; s) = f(\theta; s) + J(\theta; s)\Delta\theta \]&lt;/p&gt;

&lt;p&gt;This gives us the following linearized least squares objective function:&lt;/p&gt;

&lt;p&gt;\[ E_{LS, \theta_0} = \sum_i \vert\vert f(\theta; s_i) + J(\theta; s_i)\Delta\theta - s_i’ \vert\vert^2 \]&lt;/p&gt;

&lt;p&gt;Since the above is now linear in $\Delta\theta$, GTSAM can solve it using either sparse Cholesky or QR factorization.&lt;/p&gt;

&lt;h2 id=&quot;robust-error-models&quot;&gt;Robust Error Models&lt;/h2&gt;

&lt;p&gt;We have derived the basic parameter optimization approach in the previous section and seen how the choice of the optimization function affects the optimality of our solution. However, another aspect we need to take into account is the effect of outliers on our optimization and final parameter values.&lt;/p&gt;

&lt;p&gt;By default, the optimization objectives outlined above try to model all measurements equally. This means that in the presence of outliers, the optimization process might give us parameter estimates that try to fit these outliers, sacrificing accuracy on the inliers. More formally, given the &lt;em&gt;residual&lt;/em&gt; $r_i$ of the $i^{th}$ match, i.e. the difference between the $i^{th}$ observation and the fitted value, the standard least squares approach attempts to optimize the sum of all the squared residuals. This can lead to the estimated parameters being distorted due to the equal weighting of all data points. Surely, there must be a way for the objective to model inliers and outliers in a clever way based on the residual errors?&lt;/p&gt;

&lt;p&gt;One way to tackle the presence of outliers is a family of models known as &lt;strong&gt;Robust Error Models&lt;/strong&gt; or &lt;strong&gt;M-estimators&lt;/strong&gt;. The M-estimators try to reduce the effect of outliers by replacing the squared residuals with a function of the residuals $\rho$ that weighs each residual term by some value:&lt;/p&gt;

&lt;p&gt;\[ p = min \sum_i^n \rho(r_i) \]&lt;/p&gt;

&lt;p&gt;To allow for optimization, we define $\rho$ to be a symmetric, positive-definite function, thus it has a unique minimum at zero, and is less increasing than square.&lt;/p&gt;

&lt;p&gt;The benefit of this formulation is that we can now solve the above minimization objective as an &lt;strong&gt;Iteratively Reweighted Least Squares&lt;/strong&gt; problem. The M-estimator of the parameter vector $p$ based on $\rho$ is the value of the parameters which solves&lt;/p&gt;

&lt;p&gt;\[ \sum_i \psi(r_i)\frac{\delta r_i}{\delta p_j} = 0 \]&lt;/p&gt;

&lt;p&gt;for $j = 1, …, m$ (recall that the maximum/minimum of a function is at the point its derivative is equal to zero). Above, $\psi(x) = \frac{\delta \rho(x)}{\delta x}$ is called the &lt;strong&gt;influence function&lt;/strong&gt;, which we can use to define a &lt;strong&gt;weight function&lt;/strong&gt; $w(x) = \frac{\psi{x}}{x}$ giving the original derivative as&lt;/p&gt;

&lt;p&gt;\[ \sum_i w(r_i) r_i \frac{\delta r_i}{\delta p_j} = 0 \]&lt;/p&gt;

&lt;p&gt;which is exactly the system of equations we obtain from iterated reweighted least squares.&lt;/p&gt;

&lt;p&gt;In layman’s terms, the influence function $\psi(x)$ measures the influence of a data point on the value of the parameter estimate. This way, the estimated parameters are intelligent to outliers and only sensitive to inliers, since the are no longer susceptible to being significantly modified by a single match, thus making them &lt;strong&gt;robust&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;m-estimator-constraints&quot;&gt;M-estimator Constraints&lt;/h3&gt;

&lt;p&gt;While M-estimators provide us with significant benefits with respect to outlier modeling, they do come with some constraints which are required to enable their use in a wide variety of optimization problems.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The influence function should be bounded.&lt;/li&gt;
  &lt;li&gt;The robust estimator should be unique, i.e. it should have a unique minimum. This implies that &lt;em&gt;the individual $\rho$-function is convex in variable &lt;strong&gt;p&lt;/strong&gt;&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;The objective should have a gradient, even when the 2nd derivative is singular.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;common-m-estimators&quot;&gt;Common M-estimators&lt;/h3&gt;

&lt;p&gt;Below we list some of the common estimators from the literature and which are available out of the box in GTSAM. We also provide accompanying graphs of the corresponding &lt;strong&gt;$\rho$ function&lt;/strong&gt;, the &lt;strong&gt;influence function&lt;/strong&gt;, and the &lt;strong&gt;weight function&lt;/strong&gt; in order, allowing one to visualize the differences and effects of each estimators influence function.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Fair
&lt;img src=&quot;/assets/images/robust_estimators/fair.png&quot; alt=&quot;fair m-estimator&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Huber
&lt;img src=&quot;/assets/images/robust_estimators/huber.png&quot; alt=&quot;huber m-estimator&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cauchy
&lt;img src=&quot;/assets/images/robust_estimators/cauchy.png&quot; alt=&quot;cauchy m-estimator&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Geman-McClure
&lt;img src=&quot;/assets/images/robust_estimators/gemanmcclure.png&quot; alt=&quot;geman-mcclure m-estimator&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Welsch
&lt;img src=&quot;/assets/images/robust_estimators/welsch.png&quot; alt=&quot;welsch m-estimator&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tukey
&lt;img src=&quot;/assets/images/robust_estimators/tukey.png&quot; alt=&quot;tukey m-estimator&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;example-with-huber-noise-model&quot;&gt;Example with Huber Noise Model&lt;/h2&gt;

&lt;p&gt;Now it’s time for the real deal. So far we’ve spoken about how great robust estimators are, and how they can be easily modeled in a least squares objective, but having a concrete example and application can really help illuminate these concepts and demonstrate the power of a robust error model. In this specific case we use the &lt;strong&gt;Huber M-estimator&lt;/strong&gt;, though any other provided M-estimator can be used depending on the application or preference.&lt;/p&gt;

&lt;p&gt;For our example application, the estimation of an $SE(2)$ transformation between two objects (a scenario commonly seen in PoseSLAM applications), we go back to our image of the two books from the introduction, which we have manually labeled with matches and outliers. A RANSAC estimate using the matches gives us the $SE(2)$ paramters &lt;code class=&quot;highlighter-rouge&quot;&gt;(347.15593, 420.31040, 0.39645)&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/robust_estimators/se2_matches.png&quot; alt=&quot;Matches between books&quot; /&gt;
  &lt;figcaption&gt;&lt;b&gt;Figure 2&lt;/b&gt;: Matches between the 2 books.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;To begin, we apply a straightforward optimization process based on Factor Graphs. Using GTSAM, this can be achieved in a few lines of code. We show the core part of the example below, omitting the housekeeping and data loading for brevity.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// This is the value we wish to estimate
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pose2_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pose_expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Set up initial values, and Factor Graph
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Values&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ExpressionFactorGraph&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// provide an initial estimate which is pretty much random
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pose2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// We assume the same noise model for all points (since it is the same camera)
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;measurementNoise&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noiseModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Isotropic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sigma&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Now we add in the factors for the measurement matches.
// Matches is a vector of 4 tuples (index1, keypoint1, index2, keypoint2)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index_j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Point2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;measurement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;measurement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index_j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Point2_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;predicted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transformTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// Add the Point2 expression variable, an initial estimate, and the measurement noise.
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addExpressionFactor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predicted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;measurement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;measurementNoise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Optimize and print basic result
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Values&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LevenbergMarquardtOptimizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Final Result:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It is important to note that our initial estimate for the transform values is pretty arbitrary.
Running the above code give us the transform values &lt;code class=&quot;highlighter-rouge&quot;&gt;(305.751, 520.127, 0.284743)&lt;/code&gt;, which when compared to the RANSAC estimate doesn’t look so good.&lt;/p&gt;

&lt;p&gt;Now how about we try using M-estimators via the built-in robust error models? This is a two line change as illustrated below:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// This is the value we wish to estimate
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pose2_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pose_expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Set up initial values, and Factor Graph
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Values&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ExpressionFactorGraph&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// provide an initial estimate which is pretty much random
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pose2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// We assume the same noise model for all points (since it is the same camera)
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;measurementNoise&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noiseModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Isotropic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sigma&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/********* First change *********/&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// We define our robust error model here, providing the default parameter value for the estimator.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noiseModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Robust&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noiseModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mEstimator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Huber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.345&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;measurementNoise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Now we add in the factors for the measurement matches.
// Matches is a vector of 4 tuples (index1, keypoint1, index2, keypoint2)
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index_j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Point2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;measurement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;measurement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index_j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Point2_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;predicted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transformTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Add the Point2 expression variable, an initial estimate, and the measurement noise.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// The graph takes in factors with the robust error model.
&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/********* Second change *********/&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addExpressionFactor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predicted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;measurement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Optimize and print basic result
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Values&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LevenbergMarquardtOptimizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Final Result:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This version of the parameter estimation gives us the $SE(2)$ transform &lt;code class=&quot;highlighter-rouge&quot;&gt;(363.76, 458.966, 0.392419)&lt;/code&gt;. Quite close for only 15 total matches, especially considering 5 of the 10 were outliers! The estimates are expected to improve with more matches to further constrain the problem.&lt;/p&gt;

&lt;p&gt;As an alternate example, we look at an induced $SE(2)$ transform and try to estimate it from scratch (no manual match labeling. Our source image is one of crayon boxes retrieved from the internet, since this image lends itself to good feature detection.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/robust_estimators/original_image.png&quot; alt=&quot;original image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To model an $SE(2)$ transformation, we apply a perspective transform to the image. The transformation applied is &lt;code class=&quot;highlighter-rouge&quot;&gt;(x, y, theta) = (4.711, 3.702, 0.13963)&lt;/code&gt;. This gives us a ground truth value to compare our methods against. The transformed image can be seen below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/robust_estimators/transformed_image.png&quot; alt=&quot;Warped image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We run the standard pipeline of SIFT feature extraction and FLANN+KDTree based matching to obtain a set of matches. At this point we are ready to evaluate the different methods of estimating the transformation.&lt;/p&gt;

&lt;p&gt;The vanilla version of the parameter estimation gives us &lt;code class=&quot;highlighter-rouge&quot;&gt;(6.26294, -14.6573, 0.153888)&lt;/code&gt; which is pretty bad. However, the version with robust error models gives us &lt;code class=&quot;highlighter-rouge&quot;&gt;(4.75419, 3.60199, 0.139674)&lt;/code&gt;, which is a far better estimate when compared to the ground truth, despite the initial estimate for the transform being arbitrary. This makes it apparent that the use of robust estimators and subsequently robust error models is the way to go for use cases where outliers are a concern. Of course, providing better initial estimates will only improve the final estimate.&lt;/p&gt;

&lt;p&gt;You may ask how does this compare to our dear old friend RANSAC? Using the OpenCV implementation of RANSAC, a similar pipeline gives use the following $SE(2)$ values: &lt;code class=&quot;highlighter-rouge&quot;&gt;(4.77360, 3.69461, 0.13960)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We show, in order, the original image, its warped form, and the recovered image from the $SE(2)$ transformation estimation. The first image is from the ground truth transform, the second one is using RANSAC, the next one is using a vanilla parameter estimation approach, and the last one uses robust error models. As you can see, while the vanilla least-squares optimization result is poor compared to the ground truth, the RANSAC and the robust error model recover the transformation correctly, with the robust error model’s result being comparable to the RANSAC one.&lt;/p&gt;

&lt;figure class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/robust_estimators/ground_truth_images.png&quot; alt=&quot;ground truth&quot; /&gt;
  &lt;figcaption&gt;Image warping and recovery using ground truth SE(2) transform. The first image is the original image, the 2nd image is the transformed image, and the last one is the image we get on applying the reverse $SE(2)$ transform.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/robust_estimators/ransac_images.png&quot; alt=&quot;ransac&quot; /&gt;
  &lt;figcaption&gt;Image warping and recovery using RANSAC.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/robust_estimators/vanilla_model_images.png&quot; alt=&quot;vanilla&quot; /&gt;
  &lt;figcaption&gt;Image warping and recovery using plain old parameter estimation. You can see that the 3rd (recovered) image does not line up correctly.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/robust_estimators/robust_model_images.png&quot; alt=&quot;robust error model&quot; /&gt;
  &lt;figcaption&gt;Image warping and recovery using robust error models with parameter estimation. These results are comparable to the ones from RANSAC, demonstrating the promise of robust error models.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;!-- That's pretty close too, so why go through the headache of using robust error models? For one, unlike RANSAC, robust error models are deterministic and possess defined behavior. Moreover, one does not need to run multiple runs of optimization to obtain a consistent result, compared to RANSAC which may require hundreds of runs to converge to a good result. --&gt;

&lt;!-- ## Robust Error Models + RANSAC --&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this post, we have seen the basics of parameter estimation, a ubiquitous mathematical framework for many perception and robotics problems, and we have seen how this framework is susceptible to perturbations from outliers which can throw off the final estimate. More importantly, we have seen how a simple tool called the Robust M-estimator can easily help us deal with these outliers and their effects. An example case for $SE(2)$ transform estimation demonstrates not only their ease of use with GTSAM, but also the efficacy of the solution generated, especially when compared to widely used alternatives such as RANSAC.&lt;/p&gt;

&lt;p&gt;Furthermore, robust estimators are deterministic, ameliorating the need for the complexity that comes inherent with RANSAC. While RANSAC is a great tool, robust error models provide us with a solid alternative to be considered. With the benefits of speed, accuracy, and ease of use, robust error models make a strong case for their adoption for many related problems and we hope you will give them a shot the next time you use GTSAM.&lt;/p&gt;</content><author><name></name></author><summary type="html">Author: Varun Agrawal Website: varunagrawal.github.io</summary></entry><entry><title type="html">Legged Robot Factors Part I</title><link href="http://localhost:4000/2019/09/18/legged-robot-factors-part-I.html" rel="alternate" type="text/html" title="Legged Robot Factors Part I" /><published>2019-09-18T00:00:00-04:00</published><updated>2019-09-18T00:00:00-04:00</updated><id>http://localhost:4000/2019/09/18/legged-robot-factors-part-I</id><content type="html" xml:base="http://localhost:4000/2019/09/18/legged-robot-factors-part-I.html">&lt;p&gt;Author: Ross Hartley&lt;br /&gt;
email: &lt;a href=&quot;mailto:m.ross.hartley@gmail.com&quot;&gt;m.ross.hartley@gmail.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is the first blog post in a series about using factor graphs for legged robot state estimation. It is meant to provide a high-level overview of what I call &lt;em&gt;kinematic and contact factors&lt;/em&gt; and how they can be used in GTSAM. More details can be found in our conference papers:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1803.07531&quot;&gt;Hybrid Contact Preintegration for Visual-Inertial-Contact State Estimation Using Factor Graphs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1712.05873&quot;&gt;Legged Robot State-Estimation Through Combined Forward Kinematic and Preintegrated Contact Factors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is assumed that the reader is already familiar with the terminology and theory behind factor graph based smoothing.&lt;/p&gt;

&lt;h2 id=&quot;so-what-makes-legged-robots-different&quot;&gt;&lt;strong&gt;So, what makes legged robots different?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Factor graph methods have been widely successful for mobile robot state estimation and SLAM. A common application is the fusion of inertial data (from an IMU) with visual data (from camera and/or LiDAR sensors) to estimate the robot’s pose over time.&lt;/p&gt;

&lt;p&gt;Although this approach is often demonstrated on wheeled and flying robots, identical techniques can be applied to their walking brethren. What makes legged robots different, however, is the presence of additional encoder and contact sensors. As I’ll show, these extra sensor measurements can be leveraged to improve state estimation results.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Sensors typically found on legged robots:&lt;/strong&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;Inertial Measurement Units (IMUs)&lt;/li&gt;
    &lt;li&gt;Vision Sensors (cameras, LiDARs)&lt;/li&gt;
    &lt;li&gt;Joint Encoders&lt;/li&gt;
    &lt;li&gt;Contact Sensors&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;All of these sensors exist on the University of Michigan’s version of the Cassie robot (developed by &lt;a href=&quot;http://www.agilityrobotics.com/&quot;&gt;Agility Robotics&lt;/a&gt;), which I’ll use as a concrete example.
&lt;img src=&quot;/assets/images/Cassie.jpg&quot; alt=&quot;Cassie&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;factor-graph-formulation&quot;&gt;&lt;strong&gt;Factor Graph Formulation&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Let’s see how we can create a factor graph using these 4 sensor types to estimate the trajectory of a legged robot. Each node in the graph represents the robot’s state at a particular timestep. This state includes the 3D orientation, position, and velocity of the robot’s base frame along with the IMU biases. We also include the pose of the contact frame (where the foot hits the ground) to this list of states. For simplicity, the base frame is assumed to be collocated with the inertial/vision sensor frames.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Estimated States:&lt;/strong&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;Base pose, &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;Base velocity, &lt;code class=&quot;highlighter-rouge&quot;&gt;V&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;Contact pose, &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;IMU biases, &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Each independent sensor measurement will place a &lt;em&gt;measurement factor&lt;/em&gt; on the graph’s nodes. Solving the factor graph consists of searching for the maximum a posteriori state estimate that minimizes the error between the predicted and actual measurements.&lt;/p&gt;

&lt;p&gt;The robot’s inertial measurements can be incorporated into the graph using the &lt;em&gt;preintegrated IMU factor&lt;/em&gt; built into GTSAM 4.0. This factor relates the base pose, velocity, and IMU biases across consecutive timesteps.&lt;/p&gt;

&lt;p&gt;Vision data can be incorporated into the graph using a number of different factors depending on the sensor type and application. Here we will simply assume that vision provides a relative pose factor between two nodes in the graph. This can be from either visual odometry or loop closures.&lt;/p&gt;

&lt;p&gt;At each timestep, the joint encoder data can be used to compute the relative pose transformation between the robot’s base and contact frames (through forward kinematics). This measurement be captured in a unary &lt;strong&gt;&lt;em&gt;forward kinematic factor&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Of course, adding the &lt;em&gt;forward kinematic factor&lt;/em&gt; will not affect the optimal state estimate unless additional constraints are placed on the contact frame poses. This is achieved using a binary &lt;strong&gt;&lt;em&gt;contact factor&lt;/em&gt;&lt;/strong&gt; which uses contact measurements to infer the movement of the contact frame over time. The simplest case being contact implies zero movement of this frame. In other words, this &lt;em&gt;contact factor&lt;/em&gt; tries to keep the contact pose fixed across timesteps where contact was measured. When contact is absent, this factor can simply be omitted in the graph.&lt;/p&gt;

&lt;p&gt;If we know how the contact frame moves over time and we can measure the relative pose between the robot’s contact and base frames, then we have an implicit measurement of how the robot’s base moves over time.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The combined &lt;em&gt;forward kinematic and contact factors&lt;/em&gt; can be viewed as &lt;strong&gt;&lt;em&gt;kinematic odometry&lt;/em&gt;&lt;/strong&gt; measurements of the robot’s base frame.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;All together, a typical legged robot factor graph may be represented by the picture below. It will contain inertial, vision, forward kinematic, and contact factors.
&lt;img src=&quot;/assets/images/Factor_Graph.PNG&quot; alt=&quot;Cassie Forward Kinematics&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;forward-kinematic-factor&quot;&gt;&lt;strong&gt;Forward Kinematic Factor&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;em&gt;forward kinematics factor&lt;/em&gt; relates the base pose to the current contact pose using noisy encoder measurements. This is a simple relative pose factor which means we can use GTSAM’s built in &lt;code class=&quot;highlighter-rouge&quot;&gt;BetweenFactor&amp;lt;Pose3&amp;gt;&lt;/code&gt; factor to implement it. We just need to determine what the factor’s covariance will be.&lt;/p&gt;

&lt;p&gt;Assuming the encoder noise is gaussian, we can map the encoder covariance to the contact pose covariance using the body &lt;strong&gt;manipulator Jacobian&lt;/strong&gt; of the forward kinematics function. In general, the manipulator Jacobian maps joint angle rates to end effector twist, so it makes sense that it can be used to approximate the mapping of encoder uncertainty through the non-linearities of the robot’s kinematics.&lt;/p&gt;

&lt;p&gt;For example, if &lt;code class=&quot;highlighter-rouge&quot;&gt;H_BC&lt;/code&gt; is pose of the contact frame relative to the base frame and &lt;code class=&quot;highlighter-rouge&quot;&gt;J_BC&lt;/code&gt; is the corresponding body manipulator Jacobian, the &lt;em&gt;forward kinematic factor&lt;/em&gt; can be implemented using the following GTSAM code:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Matrix6 FK_Cov = J_BC * encoder_covariance_matrix * J_BC.transpose();
BetweenFactor&amp;lt;Pose3&amp;gt; forward_kinematics_factor(X(node), C(node), H_BC, noiseModel::Gaussian::Covariance(FK_cov));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Cassie_FK.PNG&quot; alt=&quot;Cassie Forward Kinematics&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rigid-contact-factor&quot;&gt;&lt;strong&gt;Rigid Contact Factor&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Contact factors&lt;/em&gt; come in a number of different flavors depending on the assumptions we want to make about the contact sensor measurements. However, they will all provide a measurement of contact frame odometry (i.e. how to foot will move over time).&lt;/p&gt;

&lt;p&gt;For example, in the simplest case, perhaps measuring contact implies that the entire pose of the foot remains fixed. We can call this &lt;strong&gt;rigid contact&lt;/strong&gt;, and it may be a good assumption for many humanoid robots that have large, flat feet. In contrast, we could alternatively assume a &lt;strong&gt;point contact&lt;/strong&gt;, where the position of the contact frame remains fixed, but the foot is free to rotate.&lt;/p&gt;

&lt;p&gt;For now, lets look at how we can implement a &lt;strong&gt;&lt;em&gt;rigid contact factor&lt;/em&gt;&lt;/strong&gt;.  Again, when contact is measured, we assume there is no relative change in the contact frame pose. In other words, the contact frame velocity is zero. This can be implemented in GTSAM using a &lt;code class=&quot;highlighter-rouge&quot;&gt;BetweenFactor&amp;lt;Pose3&amp;gt;&lt;/code&gt; factor, where the measurement is simply the identity element.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BetweenFactor&amp;lt;Pose3&amp;gt; contact_factor(C(node-1), C(node), Pose3::identity(), noiseModel::Gaussian::Covariance(Sigma_ij);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Some potential foot slip can be accommodated through the factor’s covariance, &lt;code class=&quot;highlighter-rouge&quot;&gt;Sigma_ij&lt;/code&gt;. If we are highly confident that the foot remained fixed on the ground, this covariance should be small. A large covariance implies less confidence in this assumption.&lt;/p&gt;

&lt;p&gt;One idea is simply assuming Gaussian noise on the contact frame velocity. In this case, the factor’s covariance will grow with the length of time between the graph nodes. Another idea is to use contact force information to model the factor’s covariance.&lt;/p&gt;

&lt;h3 id=&quot;what-happens-when-contact-is-madebroken&quot;&gt;&lt;strong&gt;What happens when contact is made/broken?&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Using the formulation above, every time contact is made or broken, a new node has to be added to the factor graph. This stems from our contact measurement assumption. When the robot loses contact, we have no way to determine the foot movement using contact sensors alone. Our only choice is to add a new node in the graph and omit the contact factor until contact is regained.&lt;/p&gt;

&lt;p&gt;This may not be an issue for some slow walking robots where contact states change infrequently, &lt;strong&gt;but what about a running hexapod?&lt;/strong&gt; In that case, the numerous contact changes will lead to an explosion in the number of nodes (and optimization variables) needed in the graph. This ultimately affects the performance of the state estimator by increasing the time it takes to solve the underlying optimization problem.&lt;/p&gt;

&lt;p&gt;Thankfully, there is a way around this problem.&lt;/p&gt;

&lt;h2 id=&quot;hybrid-rigid-contact-factor&quot;&gt;&lt;strong&gt;Hybrid Rigid Contact Factor&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;During many types of walking gaits, when one contact is broken, another is made. For example, with bipedal walking, left stance is followed by right stance, then left, then right, and so on. The order on a hexapod might be more complicated, but one fact remains: &lt;strong&gt;there is often (at least) one foot on the ground at all times&lt;/strong&gt;. We can use this knowledge to improve performance in our factor graph by limiting the insertion rate of new graph nodes.&lt;/p&gt;

&lt;p&gt;If we choose two arbitrary times (potentially far apart), any single contact is likely to have been broken at some point between them. However, there may be a &lt;strong&gt;chain of contact frames&lt;/strong&gt; that we can swap through to maintain the notion of contact with the environment. Each consecutive pair of contact frames in this chain are related to each other through forward kinematics.&lt;/p&gt;

&lt;p&gt;For example, lets say our biped robot switched from left stance (L1), to right stance (R1), back to left stance (L2) again. During the L1 phase, we can assume the contact frame pose remained fixed (zero velocity). When the robot switches from L1 to R1, we can map this contact frame from the left to the right foot using the encoder measurements and forward kinematics (since both feet are on the ground at this time). During the R1 phase, we again assume that the contact pose remains fixed. When the second swap happens, R1 to L2, we map the contact frame back to left foot using the encoder measurements and a (different) forward kinematics function. So in effect, we have tracked the movement of the contact frame across two contact switches. This relative pose measurement provides odometry for the contact frame and can be used to create a &lt;strong&gt;&lt;em&gt;hybrid rigid contact factor&lt;/em&gt;&lt;/strong&gt;. Using this method, nodes can now be added to the graph at arbitrary times, and do not have to be added when contact is made/broken (unless all feet come off the ground).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Cassie_FK_Switch.PNG&quot; alt=&quot;Cassie Forward Kinematics&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Like the original &lt;em&gt;rigid contact factor&lt;/em&gt;, the hybrid version can be created using GTSAM’s &lt;code class=&quot;highlighter-rouge&quot;&gt;BetweenFactor&amp;lt;Pose3&amp;gt;&lt;/code&gt; factor, where &lt;code class=&quot;highlighter-rouge&quot;&gt;delta_Hij&lt;/code&gt; is the cumulative change in contact pose across all contact switches. The factor’s covariance is typically larger as it needs to account for the uncertainty in each swap’s forward kinematics.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BetweenFactor&amp;lt;Pose3&amp;gt; hybrid_contact_factor(C(node-1), C(node), delta_Hij, noiseModel::Gaussian::Covariance(Sigma_ij);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;coming-soon&quot;&gt;&lt;strong&gt;Coming soon…&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;I briefly discussed two types of factors that can be used to improve legged robot state estimation: the &lt;strong&gt;&lt;em&gt;forward kinematic factor&lt;/em&gt;&lt;/strong&gt; and the &lt;strong&gt;&lt;em&gt;(hybrid) rigid contact factor&lt;/em&gt;&lt;/strong&gt;. Combining these two factors allows for kinematic odometry to be added alongside other measurements (inertial, vision, etc.) when building up a factor graph.&lt;/p&gt;

&lt;p&gt;In particular, when developing the &lt;em&gt;rigid contact factor&lt;/em&gt;, we made the strong assumption that a contact measurement implies zero angular and linear velocity of the contact frame. The factor tries to keep the entire pose of the foot fixed across two timesteps. This assumption may not be valid for all types of walking robots. In fact, it doesn’t even hold for the Cassie robot! The roll angle about Cassie’s foot is unactuated and free to move during walking. In the next post, I will discuss the &lt;strong&gt;(hybrid) point contact factor&lt;/strong&gt; which makes no assumptions about the angular velocity of the contact frame.&lt;/p&gt;</content><author><name></name></author><summary type="html">Author: Ross Hartley email: m.ross.hartley@gmail.com</summary></entry><entry><title type="html">Launching gtsam.org</title><link href="http://localhost:4000/gtsam.org/2019/05/20/gtsam-org.html" rel="alternate" type="text/html" title="Launching gtsam.org" /><published>2019-05-20T00:00:00-04:00</published><updated>2019-05-20T00:00:00-04:00</updated><id>http://localhost:4000/gtsam.org/2019/05/20/gtsam-org</id><content type="html" xml:base="http://localhost:4000/gtsam.org/2019/05/20/gtsam-org.html">&lt;p&gt;Today we launched GTSAM’s new web presence, &lt;a href=&quot;http://gtsam.org&quot;&gt;gtsam.org&lt;/a&gt;. The site is hosted by Github Pages, and is generated via &lt;a href=&quot;https://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt;, a simple static website generator.&lt;/p&gt;

&lt;p&gt;At the moment, the page still looks rather spartan, but we’ll add a little more design features as time goes on. Plans also call for blog posts (such as this one) and tutorials, on factor graphs and on GTSAM’s implementation of it.&lt;/p&gt;</content><author><name></name></author><summary type="html">Today we launched GTSAM’s new web presence, gtsam.org. The site is hosted by Github Pages, and is generated via Jekyll, a simple static website generator.</summary></entry><entry><title type="html">Moving to Github!</title><link href="http://localhost:4000/gtsam.org/2019/05/18/moving-to-github.html" rel="alternate" type="text/html" title="Moving to Github!" /><published>2019-05-18T00:00:00-04:00</published><updated>2019-05-18T00:00:00-04:00</updated><id>http://localhost:4000/gtsam.org/2019/05/18/moving-to-github</id><content type="html" xml:base="http://localhost:4000/gtsam.org/2019/05/18/moving-to-github.html">&lt;p&gt;&lt;a href=&quot;https://github.com/borglab/gtsam&quot;&gt;GTSAM is now live on Github&lt;/a&gt;. Github is doing so many things right, in addition to being the go-to platform for open source: it has free continuous integration for open source projects, it supports building great web-sites, and it is itself supporting many great efforts such as VS-code and Atom. While we initially launched GTSAM on Bitbucket because of its unlimited private repos, we felt we could hold out no longer. Github, here we come :-)&lt;/p&gt;</content><author><name></name></author><summary type="html">GTSAM is now live on Github. Github is doing so many things right, in addition to being the go-to platform for open source: it has free continuous integration for open source projects, it supports building great web-sites, and it is itself supporting many great efforts such as VS-code and Atom. While we initially launched GTSAM on Bitbucket because of its unlimited private repos, we felt we could hold out no longer. Github, here we come :-)</summary></entry></feed>