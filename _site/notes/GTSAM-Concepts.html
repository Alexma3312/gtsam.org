<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>GTSAM Concepts | GTSAM</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="GTSAM Concepts" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="As discussed in Generic Programming Techniques, concepts define" />
<meta property="og:description" content="As discussed in Generic Programming Techniques, concepts define" />
<link rel="canonical" href="http://localhost:4000/notes/GTSAM-Concepts.html" />
<meta property="og:url" content="http://localhost:4000/notes/GTSAM-Concepts.html" />
<meta property="og:site_name" content="GTSAM" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-18T14:09:48-04:00" />
<script type="application/ld+json">
{"headline":"GTSAM Concepts","description":"As discussed in Generic Programming Techniques, concepts define","dateModified":"2019-05-18T14:09:48-04:00","url":"http://localhost:4000/notes/GTSAM-Concepts.html","datePublished":"2019-05-18T14:09:48-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/notes/GTSAM-Concepts.html"},"@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/favicon.png"}},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="GTSAM" /></head>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">

  <body class=""><header class="header-holder site-header">

    <div class="wrapper"><a class="site-title" rel="author" href="/">GTSAM</a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>
  
          <div class="trigger"><a class="page-link" href="/get_started/">Get Started</a><a class="page-link" href="/build/">Build</a><a class="page-link" href="/tutorials/">Tutorials</a><a class="page-link" href="/docs/">Docs</a><a class="page-link" href="/blog/">Blog</a><a class="page-link" href="/about/">About</a></div>
        </nav></div>
  </header><div class="main-background "></div>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">GTSAM Concepts</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-05-18T14:09:48-04:00" itemprop="datePublished">May 18, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <article class="post">

  <div class="jumbotron jumbotron-fluid on-dark-background">
    <div class="container">
        <h1>GTSAM Notes</h1>
    </div>
</div>

  <div class="post-content">
    <p>As discussed in <a href="http://www.boost.org/community/generic_programming.html">Generic Programming Techniques</a>, concepts define</p>

<ul>
  <li>associated types</li>
  <li>valid expressions, like functions and values</li>
  <li>invariants</li>
  <li>complexity guarantees</li>
</ul>

<p>Below we discuss the most important concepts use in GTSAM, and after that we discuss how they are implemented/used/enforced.</p>

<h2 id="manifold">Manifold</h2>

<p>To optimize over continuous types, we assume they are manifolds. This is central to GTSAM and hence discussed in some more detail below.</p>

<p><a href="http://en.wikipedia.org/wiki/Manifold#Charts.2C_atlases.2C_and_transition_maps">Manifolds</a> and <a href="http://en.wikipedia.org/wiki/Manifold#Charts.2C_atlases.2C_and_transition_maps">charts</a> are intimately linked concepts. We are only interested here in <a href="http://en.wikipedia.org/wiki/Differentiable_manifold#Definition">differentiable manifolds</a>, continuous spaces that can be locally approximated <em>at any point</em> using a local vector space, called the <a href="http://en.wikipedia.org/wiki/Tangent_space">tangent space</a>. A <em>chart</em> is an invertible map from the manifold to that tangent space.</p>

<p>In GTSAM, all properties and operations needed to use a type must be defined through template specialization of the struct <code class="highlighter-rouge">gtsam::traits</code>. Concept checks are used to check that all required functions are implemented.
In detail, we ask that the following items are defined in the traits object (although, not all are needed for optimization):</p>

<ul>
  <li>values:
    <ul>
      <li><code class="highlighter-rouge">enum { dimension = D};</code>, an enum that indicates the dimensionality <em>n</em> of the manifold. In Eigen-fashion, we also support manifolds whose dimensionality is only defined at runtime, by specifying the value -1.</li>
    </ul>
  </li>
  <li>types:
    <ul>
      <li><code class="highlighter-rouge">TangentVector</code>, type that lives in tangent space. This will almost always be an <code class="highlighter-rouge">Eigen::Matrix&lt;double,n,1&gt;</code>.</li>
      <li><code class="highlighter-rouge">ChartJacobian</code>, a typedef for <code class="highlighter-rouge">OptionalJacobian&lt;dimension, dimension&gt;</code>.</li>
      <li><code class="highlighter-rouge">ManifoldType</code>, a pointer back to the type.</li>
      <li><code class="highlighter-rouge">structure_category</code>, a tag type that defines what requirements the type fulfills, and therefore what requirements this traits class must fulfill. It should be defined to be one of the following:
        <ul>
          <li><code class="highlighter-rouge">gtsam::traits::manifold_tag</code> – Everything in this list is expected</li>
          <li><code class="highlighter-rouge">gtsam::traits::group_tag</code> – The functions defined under <strong>Groups</strong> below.</li>
          <li><code class="highlighter-rouge">gtsam::traits::lie_group_tag</code> – Everything in this list is expected, plus the functions defined under <strong>Groups</strong>, and <strong>Lie Groups</strong> below.</li>
          <li><code class="highlighter-rouge">gtsam::traits::vector_space_tag</code> – Everything in this list is expected, plus the functions defined under <strong>Groups</strong>, and <strong>Lie Groups</strong> below.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>valid expressions:
    <ul>
      <li><code class="highlighter-rouge">size_t dim = traits&lt;T&gt;::GetDimension(p);</code> static function should be defined. This is mostly useful if the size is not known at compile time.</li>
      <li><code class="highlighter-rouge">v = traits&lt;T&gt;::Local(p,q)</code>, the chart, from manifold to tangent space, think of it as <em>q (-) p</em>, where <em>p</em> and <em>q</em> are elements of the manifold and the result, <em>v</em> is an element of the vector space.</li>
      <li><code class="highlighter-rouge">p = traits&lt;T&gt;::Retract(p,v)</code>, the inverse chart, from tangent space to manifold, think of it as <em>p (+) v</em>, where <em>p</em> is an element of the manifold and the result, <em>v</em> is an element of the vector space.</li>
    </ul>
  </li>
  <li>invariants
    <ul>
      <li><code class="highlighter-rouge">Retract(p, Local(p,q)) == q</code></li>
      <li><code class="highlighter-rouge">Local(p, Retract(p, v)) == v</code></li>
    </ul>
  </li>
</ul>

<h2 id="group">Group</h2>
<p>A <a href="&quot;http://en.wikipedia.org/wiki/Group_(mathematics)&quot;&quot;">group</a> should be well known from grade school :-), and provides a type with a composition operation that is closed, associative, has an identity element, and an inverse for each element. The following should be added to the traits class for a group:</p>

<ul>
  <li>valid expressions:
    <ul>
      <li><code class="highlighter-rouge">r = traits&lt;T&gt;::Compose(p,q)</code>, where <em>p</em>, <em>q</em>, and <em>r</em> are elements of the manifold.</li>
      <li><code class="highlighter-rouge">q = traits&lt;T&gt;::Inverse(p)</code>, where <em>p</em> and<em>q</em> are elements of the manifold.</li>
      <li><code class="highlighter-rouge">r = traits&lt;T&gt;::Between(p,q)</code>, where <em>p</em>, <em>q</em>, and <em>r</em> are elements of the manifold.</li>
    </ul>
  </li>
  <li>static members:
    <ul>
      <li><code class="highlighter-rouge">traits&lt;T&gt;::Identity</code>, a static const member that represents the group’s identity element.</li>
    </ul>
  </li>
  <li>invariants:
    <ul>
      <li><code class="highlighter-rouge">Compose(p,Inverse(p)) == Identity</code></li>
      <li><code class="highlighter-rouge">Compose(p,Between(p,q)) == q</code></li>
      <li><code class="highlighter-rouge">Between(p,q) == Compose(Inverse(p),q)</code>
The <code class="highlighter-rouge">gtsam::group::traits</code> namespace defines the following:</li>
    </ul>
  </li>
  <li>values:
    <ul>
      <li><code class="highlighter-rouge">traits&lt;T&gt;::Identity</code> – The identity element for this group stored as a static const.</li>
      <li><code class="highlighter-rouge">traits&lt;T&gt;::group_flavor</code> – the flavor of this group’s <code class="highlighter-rouge">compose()</code> operator, either:
        <ul>
          <li><code class="highlighter-rouge">gtsam::traits::group_multiplicative_tag</code> for multiplicative operator syntax ,or</li>
          <li><code class="highlighter-rouge">gtsam::traits::group_additive_tag</code> for additive operator syntax.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>We do <em>not</em> at this time support more than one composition operator per type. Although mathematically possible, it is hardly ever needed, and the machinery to support it would be burdensome and counter-intuitive.</p>

<p>Also, a type should provide either multiplication or addition operators depending on the flavor of the operation. To distinguish between the two, we will use a tag (see below).</p>

<h2 id="lie-group">Lie Group</h2>

<p>A Lie group is both a manifold <em>and</em> a group. Hence, a LIE_GROUP type should implements both MANIFOLD and GROUP concepts. 
However, we now also need to be able to evaluate the derivatives of compose and inverse. 
Hence, we have the following extra valid static functions defined in the struct <code class="highlighter-rouge">gtsam::traits&lt;T&gt;</code>:</p>

<ul>
  <li><code class="highlighter-rouge">r = traits&lt;T&gt;::Compose(p,q,Hq,Hp)</code></li>
  <li><code class="highlighter-rouge">q = traits&lt;T&gt;::Inverse(p,Hp)</code></li>
  <li><code class="highlighter-rouge">r = traits&lt;T&gt;::Between(p,q,Hq,H2p)</code></li>
</ul>

<p>where above the <em>H</em> arguments stand for optional Jacobian arguments. 
That makes it possible to create factors implementing priors (PriorFactor) or relations between two instances of a Lie group type (BetweenFactor).</p>

<p>In addition, a Lie group has a Lie algebra, which affords two extra valid expressions:</p>

<ul>
  <li><code class="highlighter-rouge">v = traits&lt;T&gt;::Logmap(p,Hp)</code>, the log map, with optional Jacobian</li>
  <li><code class="highlighter-rouge">p = traits&lt;T&gt;::Expmap(v,Hv)</code>, the exponential map, with optional Jacobian</li>
</ul>

<p>Note that in the Lie group case, the usual valid expressions for Retract and Local can be generated automatically, e.g.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    T Retract(p,v,Hp,Hv) {
      T q = Expmap(v,Hqv);
      T r = Compose(p,q,Hrp,Hrq);
      Hv = Hrq * Hqv; // chain rule
      return r;
    }
</code></pre></div></div>

<p>For Lie groups, the <code class="highlighter-rouge">exponential map</code> above is the most obvious mapping: it 
associates straight lines in the tangent space with geodesics on the manifold 
(and it’s inverse, the log map). However, there are several cases in which we deviate from this:</p>

<p>However, the exponential map is unnecessarily expensive for use in optimization. Hence, in GTSAM there is the option to provide a cheaper chart by means of the <code class="highlighter-rouge">ChartAtOrigin</code> struct in a class. This is done for <em>SE(2)</em>, <em>SO(3)</em> and <em>SE(3)</em> (see <code class="highlighter-rouge">Pose2</code>, <code class="highlighter-rouge">Rot3</code>, <code class="highlighter-rouge">Pose3</code>)</p>

<p>Most Lie groups we care about are <em>Matrix groups</em>, continuous sub-groups of <em>GL(n)</em>, the group of <em>n x n</em> invertible matrices. In this case, a lot of the derivatives calculations needed can be standardized, and this is done by the <code class="highlighter-rouge">LieGroup</code> superclass. You only need to provide an <code class="highlighter-rouge">AdjointMap</code> method.</p>

<p>A CRTP helper class <code class="highlighter-rouge">LieGroup</code> is available that can take a class and create some of the Lie group methods automatically. The class needs:</p>

<ul>
  <li>operator* : implements group operator</li>
  <li>inverse: implements group inverse</li>
  <li>AdjointMap: maps tangent vectors according to group element</li>
  <li>Expmap/Logmap: exponential map and its inverse</li>
  <li>ChartAtOrigin: struct where you define Retract/Local at origin</li>
</ul>

<p>To use, simply derive, but also say <code class="highlighter-rouge">using LieGroup&lt;Class,N&gt;::inverse</code> so you get an inverse with a derivative.</p>

<p>Finally, to create the traits automatically you can use <code class="highlighter-rouge">internal::LieGroupTraits&lt;Class&gt;</code></p>

<h2 id="vector-space">Vector Space</h2>

<p>While vector spaces are in principle also manifolds, it is overkill to think about charts etc. Really, we should simply think about vector addition and subtraction. I.e.where</p>

<ul>
  <li><code class="highlighter-rouge">Identity == 0</code></li>
  <li><code class="highlighter-rouge">Inverse(p) == -p</code></li>
  <li><code class="highlighter-rouge">Compose(p,q) == p+q</code></li>
  <li><code class="highlighter-rouge">Between(p,q) == q-p</code></li>
  <li><code class="highlighter-rouge">Local(q) == p-q</code></li>
  <li><code class="highlighter-rouge">Retract(v) == p+v</code></li>
</ul>

<p>This considerably simplifies certain operations. A <code class="highlighter-rouge">VectorSpace</code> superclass is available to implement the traits. Types that are vector space models include <code class="highlighter-rouge">Matrix</code>, <code class="highlighter-rouge">Vector</code>, any fixed or dynamic Eigen Matrix, <code class="highlighter-rouge">Point2</code>, and <code class="highlighter-rouge">Point3</code>.</p>

<h2 id="testable">Testable</h2>
<p>Unit tests heavily depend on the following two functions being defined for all types that need to be tested:</p>

<ul>
  <li>valid expressions:
    <ul>
      <li><code class="highlighter-rouge">Print(p,s)</code> where s is an optional string</li>
      <li><code class="highlighter-rouge">Equals(p,q,tol)</code> where tol is an optional (double) tolerance</li>
    </ul>
  </li>
</ul>

<h1 id="implementation">Implementation</h1>

<p>GTSAM Types start with Uppercase, e.g., <code class="highlighter-rouge">gtsam::Point2</code>, and are models of the 
TESTABLE, MANIFOLD, GROUP, LIE_GROUP, and VECTOR_SPACE concepts.</p>

<p><code class="highlighter-rouge">gtsam::traits</code> is our way to associate these concepts with types, 
and we also define a limited number of <code class="highlighter-rouge">gtsam::tags</code> to select the correct implementation
of certain functions at compile time (tag dispatching).</p>

<h2 id="traits">Traits</h2>

<p>However, a base class is not a good way to implement/check the other concepts, as we would like these
to apply equally well to types that are outside GTSAM control, e.g., <code class="highlighter-rouge">Eigen::VectorXd</code>. This is where
<a href="http://www.boost.org/doc/libs/1_57_0/libs/type_traits/doc/html/boost_typetraits/background.html">traits</a> come in.</p>

<p>We use Eigen-style or STL-style traits, that define <em>many</em> properties at once.</p>

<p>Note that not everything that makes a concept is defined by traits. Valid expressions such as traits<T>::Compose are
defined simply as static functions within the traits class.
Finally, for GTSAM types, it is perfectly acceptable (and even desired) to define associated types as internal types, 
rather than having to use traits internally.</T></p>

<h2 id="concept-checks">Concept Checks</h2>

<p>Boost provides a nice way to check whether a given type satisfies a concept. For example, the following</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BOOST_CONCEPT_ASSERT(IsVectorSpace&lt;Point2&gt;)
</code></pre></div></div>

<p>asserts that Point2 indeed is a model for the VectorSpace concept.</p>

<h1 id="future-concepts">Future Concepts</h1>

<h2 id="group-action">Group Action</h2>

<p>Group actions are concepts in and of themselves that can be concept checked (see below).
In particular, a group can <em>act</em> on another space.
For example, the <a href="http://en.wikipedia.org/wiki/Cyclic_group">cyclic group of order 6</a> can rotate 2D vectors around the origin:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q = R(i)*p
where R(i) = R(60)^i, where R(60) rotates by 60 degrees
</code></pre></div></div>

<p>Hence, we formalize by the following extension of the concept:</p>

<ul>
  <li>valid expressions:
    <ul>
      <li><code class="highlighter-rouge">q = traits&lt;T&gt;::Act(g,p)</code>, for some instance, <em>p</em>,  of a space <em>S</em>, that can be acted upon by the group element <em>g</em> to produce <em>q</em> in <em>S</em>.</li>
      <li><code class="highlighter-rouge">q = traits&lt;T&gt;::Act(g,p,Hp)</code>, if the space acted upon is a continuous differentiable manifold. *</li>
    </ul>
  </li>
</ul>

<p>In the latter case, if <em>S</em> is an n-dimensional manifold, <em>Hp</em> is an output argument that should be 
filled with the <em>nxn</em> Jacobian matrix of the action with respect to a change in <em>p</em>. It typically depends
on the group element <em>g</em>, but in most common example will <em>not</em> depend on the value of <em>p</em>. For example, in 
the cyclic group example above, we simply have</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hp = R(i)
</code></pre></div></div>

<p>Note there is no derivative of the action with respect to a change in g. That will only be defined
for Lie groups, which we introduce now.</p>

<h2 id="lie-group-action">Lie Group Action</h2>

<p>When a Lie group acts on a space, we have two derivatives to care about:</p>

<ul>
  <li><code class="highlighter-rouge">gtasm::manifold::traits&lt;T&gt;::act(g,p,Hg,Hp)</code>, if the space acted upon is a continuous differentiable manifold.</li>
</ul>

<p>An example is a <em>similarity transform</em> in 3D, which can act on 3D space, like</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q = s*R*p + t
</code></pre></div></div>

<p>Note that again the derivative in <em>p</em>,  <em>Hp</em> is simply <em>s R</em>, which depends on <em>g</em> but not on <em>p</em>. 
The derivative  in <em>g</em>,  <em>Hg</em>, is in general more complex.</p>

<p>For now, we won’t care about Lie groups acting on non-manifolds.</p>

  </div>

</article>

  </div><a class="u-url" href="/notes/GTSAM-Concepts.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">GTSAM</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">GTSAM</li><li><a class="u-email" href="mailto:frank.dellaert@gtsam.org">frank.dellaert@gtsam.org</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/borglab"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">borglab</span></a></li><li><a href="https://www.twitter.com/gtsam4"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">gtsam4</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>GTSAM is a BSD-licensed C++ library that implements sensor fusion for robotics and computer vision using factor graphs.</p>
      </div>
    </div>

  </div>

</footer>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
          renderMathInElement(document.body, {
              delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\[", right: "\\]", display: true},
                {left: "\\(", right: "\\)", display: false},
              ]
          });
      });
    </script>

  </body>

</html>